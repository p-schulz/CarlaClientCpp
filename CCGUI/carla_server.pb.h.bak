// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: carla_server.proto

#ifndef PROTOBUF_INCLUDED_carla_5fserver_2eproto
#define PROTOBUF_INCLUDED_carla_5fserver_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_carla_5fserver_2eproto 

namespace protobuf_carla_5fserver_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[17];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_carla_5fserver_2eproto
namespace carla_server {
class Agent;
class AgentDefaultTypeInternal;
extern AgentDefaultTypeInternal _Agent_default_instance_;
class BoundingBox;
class BoundingBoxDefaultTypeInternal;
extern BoundingBoxDefaultTypeInternal _BoundingBox_default_instance_;
class Control;
class ControlDefaultTypeInternal;
extern ControlDefaultTypeInternal _Control_default_instance_;
class EpisodeReady;
class EpisodeReadyDefaultTypeInternal;
extern EpisodeReadyDefaultTypeInternal _EpisodeReady_default_instance_;
class EpisodeStart;
class EpisodeStartDefaultTypeInternal;
extern EpisodeStartDefaultTypeInternal _EpisodeStart_default_instance_;
class Measurements;
class MeasurementsDefaultTypeInternal;
extern MeasurementsDefaultTypeInternal _Measurements_default_instance_;
class Measurements_PlayerMeasurements;
class Measurements_PlayerMeasurementsDefaultTypeInternal;
extern Measurements_PlayerMeasurementsDefaultTypeInternal _Measurements_PlayerMeasurements_default_instance_;
class Pedestrian;
class PedestrianDefaultTypeInternal;
extern PedestrianDefaultTypeInternal _Pedestrian_default_instance_;
class RequestNewEpisode;
class RequestNewEpisodeDefaultTypeInternal;
extern RequestNewEpisodeDefaultTypeInternal _RequestNewEpisode_default_instance_;
class Rotation3D;
class Rotation3DDefaultTypeInternal;
extern Rotation3DDefaultTypeInternal _Rotation3D_default_instance_;
class SceneDescription;
class SceneDescriptionDefaultTypeInternal;
extern SceneDescriptionDefaultTypeInternal _SceneDescription_default_instance_;
class Sensor;
class SensorDefaultTypeInternal;
extern SensorDefaultTypeInternal _Sensor_default_instance_;
class SpeedLimitSign;
class SpeedLimitSignDefaultTypeInternal;
extern SpeedLimitSignDefaultTypeInternal _SpeedLimitSign_default_instance_;
class TrafficLight;
class TrafficLightDefaultTypeInternal;
extern TrafficLightDefaultTypeInternal _TrafficLight_default_instance_;
class Transform;
class TransformDefaultTypeInternal;
extern TransformDefaultTypeInternal _Transform_default_instance_;
class Vector3D;
class Vector3DDefaultTypeInternal;
extern Vector3DDefaultTypeInternal _Vector3D_default_instance_;
class Vehicle;
class VehicleDefaultTypeInternal;
extern VehicleDefaultTypeInternal _Vehicle_default_instance_;
}  // namespace carla_server
namespace google {
namespace protobuf {
template<> ::carla_server::Agent* Arena::CreateMaybeMessage<::carla_server::Agent>(Arena*);
template<> ::carla_server::BoundingBox* Arena::CreateMaybeMessage<::carla_server::BoundingBox>(Arena*);
template<> ::carla_server::Control* Arena::CreateMaybeMessage<::carla_server::Control>(Arena*);
template<> ::carla_server::EpisodeReady* Arena::CreateMaybeMessage<::carla_server::EpisodeReady>(Arena*);
template<> ::carla_server::EpisodeStart* Arena::CreateMaybeMessage<::carla_server::EpisodeStart>(Arena*);
template<> ::carla_server::Measurements* Arena::CreateMaybeMessage<::carla_server::Measurements>(Arena*);
template<> ::carla_server::Measurements_PlayerMeasurements* Arena::CreateMaybeMessage<::carla_server::Measurements_PlayerMeasurements>(Arena*);
template<> ::carla_server::Pedestrian* Arena::CreateMaybeMessage<::carla_server::Pedestrian>(Arena*);
template<> ::carla_server::RequestNewEpisode* Arena::CreateMaybeMessage<::carla_server::RequestNewEpisode>(Arena*);
template<> ::carla_server::Rotation3D* Arena::CreateMaybeMessage<::carla_server::Rotation3D>(Arena*);
template<> ::carla_server::SceneDescription* Arena::CreateMaybeMessage<::carla_server::SceneDescription>(Arena*);
template<> ::carla_server::Sensor* Arena::CreateMaybeMessage<::carla_server::Sensor>(Arena*);
template<> ::carla_server::SpeedLimitSign* Arena::CreateMaybeMessage<::carla_server::SpeedLimitSign>(Arena*);
template<> ::carla_server::TrafficLight* Arena::CreateMaybeMessage<::carla_server::TrafficLight>(Arena*);
template<> ::carla_server::Transform* Arena::CreateMaybeMessage<::carla_server::Transform>(Arena*);
template<> ::carla_server::Vector3D* Arena::CreateMaybeMessage<::carla_server::Vector3D>(Arena*);
template<> ::carla_server::Vehicle* Arena::CreateMaybeMessage<::carla_server::Vehicle>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace carla_server {

enum Sensor_Type {
  Sensor_Type_UNKNOWN = 0,
  Sensor_Type_CAMERA = 1,
  Sensor_Type_LIDAR_RAY_CAST = 2,
  Sensor_Type_Sensor_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Sensor_Type_Sensor_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Sensor_Type_IsValid(int value);
const Sensor_Type Sensor_Type_Type_MIN = Sensor_Type_UNKNOWN;
const Sensor_Type Sensor_Type_Type_MAX = Sensor_Type_LIDAR_RAY_CAST;
const int Sensor_Type_Type_ARRAYSIZE = Sensor_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Sensor_Type_descriptor();
inline const ::std::string& Sensor_Type_Name(Sensor_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Sensor_Type_descriptor(), value);
}
inline bool Sensor_Type_Parse(
    const ::std::string& name, Sensor_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Sensor_Type>(
    Sensor_Type_descriptor(), name, value);
}
enum TrafficLight_State {
  TrafficLight_State_GREEN = 0,
  TrafficLight_State_YELLOW = 1,
  TrafficLight_State_RED = 2,
  TrafficLight_State_TrafficLight_State_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  TrafficLight_State_TrafficLight_State_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool TrafficLight_State_IsValid(int value);
const TrafficLight_State TrafficLight_State_State_MIN = TrafficLight_State_GREEN;
const TrafficLight_State TrafficLight_State_State_MAX = TrafficLight_State_RED;
const int TrafficLight_State_State_ARRAYSIZE = TrafficLight_State_State_MAX + 1;

const ::google::protobuf::EnumDescriptor* TrafficLight_State_descriptor();
inline const ::std::string& TrafficLight_State_Name(TrafficLight_State value) {
  return ::google::protobuf::internal::NameOfEnum(
    TrafficLight_State_descriptor(), value);
}
inline bool TrafficLight_State_Parse(
    const ::std::string& name, TrafficLight_State* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TrafficLight_State>(
    TrafficLight_State_descriptor(), name, value);
}
// ===================================================================

class Vector3D : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:carla_server.Vector3D) */ {
 public:
  Vector3D();
  virtual ~Vector3D();

  Vector3D(const Vector3D& from);

  inline Vector3D& operator=(const Vector3D& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Vector3D(Vector3D&& from) noexcept
    : Vector3D() {
    *this = ::std::move(from);
  }

  inline Vector3D& operator=(Vector3D&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Vector3D& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Vector3D* internal_default_instance() {
    return reinterpret_cast<const Vector3D*>(
               &_Vector3D_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void UnsafeArenaSwap(Vector3D* other);
  void Swap(Vector3D* other);
  friend void swap(Vector3D& a, Vector3D& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Vector3D* New() const final {
    return CreateMaybeMessage<Vector3D>(NULL);
  }

  Vector3D* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Vector3D>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Vector3D& from);
  void MergeFrom(const Vector3D& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vector3D* other);
  protected:
  explicit Vector3D(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float x = 1;
  void clear_x();
  static const int kXFieldNumber = 1;
  float x() const;
  void set_x(float value);

  // float y = 2;
  void clear_y();
  static const int kYFieldNumber = 2;
  float y() const;
  void set_y(float value);

  // float z = 3;
  void clear_z();
  static const int kZFieldNumber = 3;
  float z() const;
  void set_z(float value);

  // @@protoc_insertion_point(class_scope:carla_server.Vector3D)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float x_;
  float y_;
  float z_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_carla_5fserver_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Rotation3D : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:carla_server.Rotation3D) */ {
 public:
  Rotation3D();
  virtual ~Rotation3D();

  Rotation3D(const Rotation3D& from);

  inline Rotation3D& operator=(const Rotation3D& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Rotation3D(Rotation3D&& from) noexcept
    : Rotation3D() {
    *this = ::std::move(from);
  }

  inline Rotation3D& operator=(Rotation3D&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Rotation3D& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Rotation3D* internal_default_instance() {
    return reinterpret_cast<const Rotation3D*>(
               &_Rotation3D_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void UnsafeArenaSwap(Rotation3D* other);
  void Swap(Rotation3D* other);
  friend void swap(Rotation3D& a, Rotation3D& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Rotation3D* New() const final {
    return CreateMaybeMessage<Rotation3D>(NULL);
  }

  Rotation3D* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Rotation3D>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Rotation3D& from);
  void MergeFrom(const Rotation3D& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Rotation3D* other);
  protected:
  explicit Rotation3D(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float pitch = 1;
  void clear_pitch();
  static const int kPitchFieldNumber = 1;
  float pitch() const;
  void set_pitch(float value);

  // float yaw = 2;
  void clear_yaw();
  static const int kYawFieldNumber = 2;
  float yaw() const;
  void set_yaw(float value);

  // float roll = 3;
  void clear_roll();
  static const int kRollFieldNumber = 3;
  float roll() const;
  void set_roll(float value);

  // @@protoc_insertion_point(class_scope:carla_server.Rotation3D)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float pitch_;
  float yaw_;
  float roll_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_carla_5fserver_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Transform : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:carla_server.Transform) */ {
 public:
  Transform();
  virtual ~Transform();

  Transform(const Transform& from);

  inline Transform& operator=(const Transform& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Transform(Transform&& from) noexcept
    : Transform() {
    *this = ::std::move(from);
  }

  inline Transform& operator=(Transform&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Transform& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Transform* internal_default_instance() {
    return reinterpret_cast<const Transform*>(
               &_Transform_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void UnsafeArenaSwap(Transform* other);
  void Swap(Transform* other);
  friend void swap(Transform& a, Transform& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Transform* New() const final {
    return CreateMaybeMessage<Transform>(NULL);
  }

  Transform* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Transform>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Transform& from);
  void MergeFrom(const Transform& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Transform* other);
  protected:
  explicit Transform(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .carla_server.Vector3D location = 1;
  bool has_location() const;
  void clear_location();
  static const int kLocationFieldNumber = 1;
  private:
  const ::carla_server::Vector3D& _internal_location() const;
  public:
  const ::carla_server::Vector3D& location() const;
  ::carla_server::Vector3D* release_location();
  ::carla_server::Vector3D* mutable_location();
  void set_allocated_location(::carla_server::Vector3D* location);
  void unsafe_arena_set_allocated_location(
      ::carla_server::Vector3D* location);
  ::carla_server::Vector3D* unsafe_arena_release_location();

  // .carla_server.Vector3D orientation = 2 [deprecated = true];
  GOOGLE_PROTOBUF_DEPRECATED_ATTR bool has_orientation() const;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void clear_orientation();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR static const int kOrientationFieldNumber = 2;
  private:
  const ::carla_server::Vector3D& _internal_orientation() const;
  public:
  GOOGLE_PROTOBUF_DEPRECATED_ATTR const ::carla_server::Vector3D& orientation() const;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR ::carla_server::Vector3D* release_orientation();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR ::carla_server::Vector3D* mutable_orientation();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void set_allocated_orientation(::carla_server::Vector3D* orientation);
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void unsafe_arena_set_allocated_orientation(
      ::carla_server::Vector3D* orientation);
  GOOGLE_PROTOBUF_DEPRECATED_ATTR ::carla_server::Vector3D* unsafe_arena_release_orientation();

  // .carla_server.Rotation3D rotation = 3;
  bool has_rotation() const;
  void clear_rotation();
  static const int kRotationFieldNumber = 3;
  private:
  const ::carla_server::Rotation3D& _internal_rotation() const;
  public:
  const ::carla_server::Rotation3D& rotation() const;
  ::carla_server::Rotation3D* release_rotation();
  ::carla_server::Rotation3D* mutable_rotation();
  void set_allocated_rotation(::carla_server::Rotation3D* rotation);
  void unsafe_arena_set_allocated_rotation(
      ::carla_server::Rotation3D* rotation);
  ::carla_server::Rotation3D* unsafe_arena_release_rotation();

  // @@protoc_insertion_point(class_scope:carla_server.Transform)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::carla_server::Vector3D* location_;
  ::carla_server::Vector3D* orientation_;
  ::carla_server::Rotation3D* rotation_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_carla_5fserver_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BoundingBox : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:carla_server.BoundingBox) */ {
 public:
  BoundingBox();
  virtual ~BoundingBox();

  BoundingBox(const BoundingBox& from);

  inline BoundingBox& operator=(const BoundingBox& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BoundingBox(BoundingBox&& from) noexcept
    : BoundingBox() {
    *this = ::std::move(from);
  }

  inline BoundingBox& operator=(BoundingBox&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const BoundingBox& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BoundingBox* internal_default_instance() {
    return reinterpret_cast<const BoundingBox*>(
               &_BoundingBox_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void UnsafeArenaSwap(BoundingBox* other);
  void Swap(BoundingBox* other);
  friend void swap(BoundingBox& a, BoundingBox& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BoundingBox* New() const final {
    return CreateMaybeMessage<BoundingBox>(NULL);
  }

  BoundingBox* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BoundingBox>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BoundingBox& from);
  void MergeFrom(const BoundingBox& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BoundingBox* other);
  protected:
  explicit BoundingBox(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .carla_server.Transform transform = 1;
  bool has_transform() const;
  void clear_transform();
  static const int kTransformFieldNumber = 1;
  private:
  const ::carla_server::Transform& _internal_transform() const;
  public:
  const ::carla_server::Transform& transform() const;
  ::carla_server::Transform* release_transform();
  ::carla_server::Transform* mutable_transform();
  void set_allocated_transform(::carla_server::Transform* transform);
  void unsafe_arena_set_allocated_transform(
      ::carla_server::Transform* transform);
  ::carla_server::Transform* unsafe_arena_release_transform();

  // .carla_server.Vector3D extent = 2;
  bool has_extent() const;
  void clear_extent();
  static const int kExtentFieldNumber = 2;
  private:
  const ::carla_server::Vector3D& _internal_extent() const;
  public:
  const ::carla_server::Vector3D& extent() const;
  ::carla_server::Vector3D* release_extent();
  ::carla_server::Vector3D* mutable_extent();
  void set_allocated_extent(::carla_server::Vector3D* extent);
  void unsafe_arena_set_allocated_extent(
      ::carla_server::Vector3D* extent);
  ::carla_server::Vector3D* unsafe_arena_release_extent();

  // @@protoc_insertion_point(class_scope:carla_server.BoundingBox)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::carla_server::Transform* transform_;
  ::carla_server::Vector3D* extent_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_carla_5fserver_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Sensor : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:carla_server.Sensor) */ {
 public:
  Sensor();
  virtual ~Sensor();

  Sensor(const Sensor& from);

  inline Sensor& operator=(const Sensor& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Sensor(Sensor&& from) noexcept
    : Sensor() {
    *this = ::std::move(from);
  }

  inline Sensor& operator=(Sensor&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Sensor& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Sensor* internal_default_instance() {
    return reinterpret_cast<const Sensor*>(
               &_Sensor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void UnsafeArenaSwap(Sensor* other);
  void Swap(Sensor* other);
  friend void swap(Sensor& a, Sensor& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Sensor* New() const final {
    return CreateMaybeMessage<Sensor>(NULL);
  }

  Sensor* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Sensor>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Sensor& from);
  void MergeFrom(const Sensor& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Sensor* other);
  protected:
  explicit Sensor(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Sensor_Type Type;
  static const Type UNKNOWN =
    Sensor_Type_UNKNOWN;
  static const Type CAMERA =
    Sensor_Type_CAMERA;
  static const Type LIDAR_RAY_CAST =
    Sensor_Type_LIDAR_RAY_CAST;
  static inline bool Type_IsValid(int value) {
    return Sensor_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Sensor_Type_Type_MIN;
  static const Type Type_MAX =
    Sensor_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Sensor_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Sensor_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Sensor_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Sensor_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // string name = 3;
  void clear_name();
  static const int kNameFieldNumber = 3;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_name();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_name(
      ::std::string* name);

  // fixed32 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::uint32 id() const;
  void set_id(::google::protobuf::uint32 value);

  // .carla_server.Sensor.Type type = 2;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::carla_server::Sensor_Type type() const;
  void set_type(::carla_server::Sensor_Type value);

  // @@protoc_insertion_point(class_scope:carla_server.Sensor)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::uint32 id_;
  int type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_carla_5fserver_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Vehicle : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:carla_server.Vehicle) */ {
 public:
  Vehicle();
  virtual ~Vehicle();

  Vehicle(const Vehicle& from);

  inline Vehicle& operator=(const Vehicle& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Vehicle(Vehicle&& from) noexcept
    : Vehicle() {
    *this = ::std::move(from);
  }

  inline Vehicle& operator=(Vehicle&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Vehicle& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Vehicle* internal_default_instance() {
    return reinterpret_cast<const Vehicle*>(
               &_Vehicle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void UnsafeArenaSwap(Vehicle* other);
  void Swap(Vehicle* other);
  friend void swap(Vehicle& a, Vehicle& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Vehicle* New() const final {
    return CreateMaybeMessage<Vehicle>(NULL);
  }

  Vehicle* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Vehicle>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Vehicle& from);
  void MergeFrom(const Vehicle& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vehicle* other);
  protected:
  explicit Vehicle(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .carla_server.Transform transform = 1;
  bool has_transform() const;
  void clear_transform();
  static const int kTransformFieldNumber = 1;
  private:
  const ::carla_server::Transform& _internal_transform() const;
  public:
  const ::carla_server::Transform& transform() const;
  ::carla_server::Transform* release_transform();
  ::carla_server::Transform* mutable_transform();
  void set_allocated_transform(::carla_server::Transform* transform);
  void unsafe_arena_set_allocated_transform(
      ::carla_server::Transform* transform);
  ::carla_server::Transform* unsafe_arena_release_transform();

  // .carla_server.BoundingBox bounding_box = 4;
  bool has_bounding_box() const;
  void clear_bounding_box();
  static const int kBoundingBoxFieldNumber = 4;
  private:
  const ::carla_server::BoundingBox& _internal_bounding_box() const;
  public:
  const ::carla_server::BoundingBox& bounding_box() const;
  ::carla_server::BoundingBox* release_bounding_box();
  ::carla_server::BoundingBox* mutable_bounding_box();
  void set_allocated_bounding_box(::carla_server::BoundingBox* bounding_box);
  void unsafe_arena_set_allocated_bounding_box(
      ::carla_server::BoundingBox* bounding_box);
  ::carla_server::BoundingBox* unsafe_arena_release_bounding_box();

  // float forward_speed = 3;
  void clear_forward_speed();
  static const int kForwardSpeedFieldNumber = 3;
  float forward_speed() const;
  void set_forward_speed(float value);

  // @@protoc_insertion_point(class_scope:carla_server.Vehicle)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::carla_server::Transform* transform_;
  ::carla_server::BoundingBox* bounding_box_;
  float forward_speed_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_carla_5fserver_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Pedestrian : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:carla_server.Pedestrian) */ {
 public:
  Pedestrian();
  virtual ~Pedestrian();

  Pedestrian(const Pedestrian& from);

  inline Pedestrian& operator=(const Pedestrian& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Pedestrian(Pedestrian&& from) noexcept
    : Pedestrian() {
    *this = ::std::move(from);
  }

  inline Pedestrian& operator=(Pedestrian&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Pedestrian& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Pedestrian* internal_default_instance() {
    return reinterpret_cast<const Pedestrian*>(
               &_Pedestrian_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void UnsafeArenaSwap(Pedestrian* other);
  void Swap(Pedestrian* other);
  friend void swap(Pedestrian& a, Pedestrian& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Pedestrian* New() const final {
    return CreateMaybeMessage<Pedestrian>(NULL);
  }

  Pedestrian* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Pedestrian>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Pedestrian& from);
  void MergeFrom(const Pedestrian& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Pedestrian* other);
  protected:
  explicit Pedestrian(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .carla_server.Transform transform = 1;
  bool has_transform() const;
  void clear_transform();
  static const int kTransformFieldNumber = 1;
  private:
  const ::carla_server::Transform& _internal_transform() const;
  public:
  const ::carla_server::Transform& transform() const;
  ::carla_server::Transform* release_transform();
  ::carla_server::Transform* mutable_transform();
  void set_allocated_transform(::carla_server::Transform* transform);
  void unsafe_arena_set_allocated_transform(
      ::carla_server::Transform* transform);
  ::carla_server::Transform* unsafe_arena_release_transform();

  // .carla_server.BoundingBox bounding_box = 4;
  bool has_bounding_box() const;
  void clear_bounding_box();
  static const int kBoundingBoxFieldNumber = 4;
  private:
  const ::carla_server::BoundingBox& _internal_bounding_box() const;
  public:
  const ::carla_server::BoundingBox& bounding_box() const;
  ::carla_server::BoundingBox* release_bounding_box();
  ::carla_server::BoundingBox* mutable_bounding_box();
  void set_allocated_bounding_box(::carla_server::BoundingBox* bounding_box);
  void unsafe_arena_set_allocated_bounding_box(
      ::carla_server::BoundingBox* bounding_box);
  ::carla_server::BoundingBox* unsafe_arena_release_bounding_box();

  // float forward_speed = 3;
  void clear_forward_speed();
  static const int kForwardSpeedFieldNumber = 3;
  float forward_speed() const;
  void set_forward_speed(float value);

  // @@protoc_insertion_point(class_scope:carla_server.Pedestrian)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::carla_server::Transform* transform_;
  ::carla_server::BoundingBox* bounding_box_;
  float forward_speed_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_carla_5fserver_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TrafficLight : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:carla_server.TrafficLight) */ {
 public:
  TrafficLight();
  virtual ~TrafficLight();

  TrafficLight(const TrafficLight& from);

  inline TrafficLight& operator=(const TrafficLight& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TrafficLight(TrafficLight&& from) noexcept
    : TrafficLight() {
    *this = ::std::move(from);
  }

  inline TrafficLight& operator=(TrafficLight&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const TrafficLight& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TrafficLight* internal_default_instance() {
    return reinterpret_cast<const TrafficLight*>(
               &_TrafficLight_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void UnsafeArenaSwap(TrafficLight* other);
  void Swap(TrafficLight* other);
  friend void swap(TrafficLight& a, TrafficLight& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TrafficLight* New() const final {
    return CreateMaybeMessage<TrafficLight>(NULL);
  }

  TrafficLight* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TrafficLight>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TrafficLight& from);
  void MergeFrom(const TrafficLight& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrafficLight* other);
  protected:
  explicit TrafficLight(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TrafficLight_State State;
  static const State GREEN =
    TrafficLight_State_GREEN;
  static const State YELLOW =
    TrafficLight_State_YELLOW;
  static const State RED =
    TrafficLight_State_RED;
  static inline bool State_IsValid(int value) {
    return TrafficLight_State_IsValid(value);
  }
  static const State State_MIN =
    TrafficLight_State_State_MIN;
  static const State State_MAX =
    TrafficLight_State_State_MAX;
  static const int State_ARRAYSIZE =
    TrafficLight_State_State_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  State_descriptor() {
    return TrafficLight_State_descriptor();
  }
  static inline const ::std::string& State_Name(State value) {
    return TrafficLight_State_Name(value);
  }
  static inline bool State_Parse(const ::std::string& name,
      State* value) {
    return TrafficLight_State_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .carla_server.Transform transform = 1;
  bool has_transform() const;
  void clear_transform();
  static const int kTransformFieldNumber = 1;
  private:
  const ::carla_server::Transform& _internal_transform() const;
  public:
  const ::carla_server::Transform& transform() const;
  ::carla_server::Transform* release_transform();
  ::carla_server::Transform* mutable_transform();
  void set_allocated_transform(::carla_server::Transform* transform);
  void unsafe_arena_set_allocated_transform(
      ::carla_server::Transform* transform);
  ::carla_server::Transform* unsafe_arena_release_transform();

  // .carla_server.TrafficLight.State state = 2;
  void clear_state();
  static const int kStateFieldNumber = 2;
  ::carla_server::TrafficLight_State state() const;
  void set_state(::carla_server::TrafficLight_State value);

  // @@protoc_insertion_point(class_scope:carla_server.TrafficLight)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::carla_server::Transform* transform_;
  int state_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_carla_5fserver_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SpeedLimitSign : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:carla_server.SpeedLimitSign) */ {
 public:
  SpeedLimitSign();
  virtual ~SpeedLimitSign();

  SpeedLimitSign(const SpeedLimitSign& from);

  inline SpeedLimitSign& operator=(const SpeedLimitSign& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SpeedLimitSign(SpeedLimitSign&& from) noexcept
    : SpeedLimitSign() {
    *this = ::std::move(from);
  }

  inline SpeedLimitSign& operator=(SpeedLimitSign&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const SpeedLimitSign& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SpeedLimitSign* internal_default_instance() {
    return reinterpret_cast<const SpeedLimitSign*>(
               &_SpeedLimitSign_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void UnsafeArenaSwap(SpeedLimitSign* other);
  void Swap(SpeedLimitSign* other);
  friend void swap(SpeedLimitSign& a, SpeedLimitSign& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SpeedLimitSign* New() const final {
    return CreateMaybeMessage<SpeedLimitSign>(NULL);
  }

  SpeedLimitSign* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SpeedLimitSign>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SpeedLimitSign& from);
  void MergeFrom(const SpeedLimitSign& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpeedLimitSign* other);
  protected:
  explicit SpeedLimitSign(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .carla_server.Transform transform = 1;
  bool has_transform() const;
  void clear_transform();
  static const int kTransformFieldNumber = 1;
  private:
  const ::carla_server::Transform& _internal_transform() const;
  public:
  const ::carla_server::Transform& transform() const;
  ::carla_server::Transform* release_transform();
  ::carla_server::Transform* mutable_transform();
  void set_allocated_transform(::carla_server::Transform* transform);
  void unsafe_arena_set_allocated_transform(
      ::carla_server::Transform* transform);
  ::carla_server::Transform* unsafe_arena_release_transform();

  // float speed_limit = 2;
  void clear_speed_limit();
  static const int kSpeedLimitFieldNumber = 2;
  float speed_limit() const;
  void set_speed_limit(float value);

  // @@protoc_insertion_point(class_scope:carla_server.SpeedLimitSign)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::carla_server::Transform* transform_;
  float speed_limit_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_carla_5fserver_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Agent : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:carla_server.Agent) */ {
 public:
  Agent();
  virtual ~Agent();

  Agent(const Agent& from);

  inline Agent& operator=(const Agent& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Agent(Agent&& from) noexcept
    : Agent() {
    *this = ::std::move(from);
  }

  inline Agent& operator=(Agent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Agent& default_instance();

  enum AgentCase {
    kVehicle = 2,
    kPedestrian = 3,
    kTrafficLight = 4,
    kSpeedLimitSign = 5,
    AGENT_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Agent* internal_default_instance() {
    return reinterpret_cast<const Agent*>(
               &_Agent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void UnsafeArenaSwap(Agent* other);
  void Swap(Agent* other);
  friend void swap(Agent& a, Agent& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Agent* New() const final {
    return CreateMaybeMessage<Agent>(NULL);
  }

  Agent* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Agent>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Agent& from);
  void MergeFrom(const Agent& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Agent* other);
  protected:
  explicit Agent(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // fixed32 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::uint32 id() const;
  void set_id(::google::protobuf::uint32 value);

  // .carla_server.Vehicle vehicle = 2;
  bool has_vehicle() const;
  void clear_vehicle();
  static const int kVehicleFieldNumber = 2;
  private:
  const ::carla_server::Vehicle& _internal_vehicle() const;
  public:
  const ::carla_server::Vehicle& vehicle() const;
  ::carla_server::Vehicle* release_vehicle();
  ::carla_server::Vehicle* mutable_vehicle();
  void set_allocated_vehicle(::carla_server::Vehicle* vehicle);
  void unsafe_arena_set_allocated_vehicle(
      ::carla_server::Vehicle* vehicle);
  ::carla_server::Vehicle* unsafe_arena_release_vehicle();

  // .carla_server.Pedestrian pedestrian = 3;
  bool has_pedestrian() const;
  void clear_pedestrian();
  static const int kPedestrianFieldNumber = 3;
  private:
  const ::carla_server::Pedestrian& _internal_pedestrian() const;
  public:
  const ::carla_server::Pedestrian& pedestrian() const;
  ::carla_server::Pedestrian* release_pedestrian();
  ::carla_server::Pedestrian* mutable_pedestrian();
  void set_allocated_pedestrian(::carla_server::Pedestrian* pedestrian);
  void unsafe_arena_set_allocated_pedestrian(
      ::carla_server::Pedestrian* pedestrian);
  ::carla_server::Pedestrian* unsafe_arena_release_pedestrian();

  // .carla_server.TrafficLight traffic_light = 4;
  bool has_traffic_light() const;
  void clear_traffic_light();
  static const int kTrafficLightFieldNumber = 4;
  private:
  const ::carla_server::TrafficLight& _internal_traffic_light() const;
  public:
  const ::carla_server::TrafficLight& traffic_light() const;
  ::carla_server::TrafficLight* release_traffic_light();
  ::carla_server::TrafficLight* mutable_traffic_light();
  void set_allocated_traffic_light(::carla_server::TrafficLight* traffic_light);
  void unsafe_arena_set_allocated_traffic_light(
      ::carla_server::TrafficLight* traffic_light);
  ::carla_server::TrafficLight* unsafe_arena_release_traffic_light();

  // .carla_server.SpeedLimitSign speed_limit_sign = 5;
  bool has_speed_limit_sign() const;
  void clear_speed_limit_sign();
  static const int kSpeedLimitSignFieldNumber = 5;
  private:
  const ::carla_server::SpeedLimitSign& _internal_speed_limit_sign() const;
  public:
  const ::carla_server::SpeedLimitSign& speed_limit_sign() const;
  ::carla_server::SpeedLimitSign* release_speed_limit_sign();
  ::carla_server::SpeedLimitSign* mutable_speed_limit_sign();
  void set_allocated_speed_limit_sign(::carla_server::SpeedLimitSign* speed_limit_sign);
  void unsafe_arena_set_allocated_speed_limit_sign(
      ::carla_server::SpeedLimitSign* speed_limit_sign);
  ::carla_server::SpeedLimitSign* unsafe_arena_release_speed_limit_sign();

  void clear_agent();
  AgentCase agent_case() const;
  // @@protoc_insertion_point(class_scope:carla_server.Agent)
 private:
  void set_has_vehicle();
  void set_has_pedestrian();
  void set_has_traffic_light();
  void set_has_speed_limit_sign();

  inline bool has_agent() const;
  inline void clear_has_agent();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::uint32 id_;
  union AgentUnion {
    AgentUnion() {}
    ::carla_server::Vehicle* vehicle_;
    ::carla_server::Pedestrian* pedestrian_;
    ::carla_server::TrafficLight* traffic_light_;
    ::carla_server::SpeedLimitSign* speed_limit_sign_;
  } agent_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_carla_5fserver_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RequestNewEpisode : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:carla_server.RequestNewEpisode) */ {
 public:
  RequestNewEpisode();
  virtual ~RequestNewEpisode();

  RequestNewEpisode(const RequestNewEpisode& from);

  inline RequestNewEpisode& operator=(const RequestNewEpisode& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RequestNewEpisode(RequestNewEpisode&& from) noexcept
    : RequestNewEpisode() {
    *this = ::std::move(from);
  }

  inline RequestNewEpisode& operator=(RequestNewEpisode&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestNewEpisode& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestNewEpisode* internal_default_instance() {
    return reinterpret_cast<const RequestNewEpisode*>(
               &_RequestNewEpisode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void UnsafeArenaSwap(RequestNewEpisode* other);
  void Swap(RequestNewEpisode* other);
  friend void swap(RequestNewEpisode& a, RequestNewEpisode& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestNewEpisode* New() const final {
    return CreateMaybeMessage<RequestNewEpisode>(NULL);
  }

  RequestNewEpisode* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RequestNewEpisode>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RequestNewEpisode& from);
  void MergeFrom(const RequestNewEpisode& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestNewEpisode* other);
  protected:
  explicit RequestNewEpisode(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string ini_file = 1;
  void clear_ini_file();
  static const int kIniFileFieldNumber = 1;
  const ::std::string& ini_file() const;
  void set_ini_file(const ::std::string& value);
  #if LANG_CXX11
  void set_ini_file(::std::string&& value);
  #endif
  void set_ini_file(const char* value);
  void set_ini_file(const char* value, size_t size);
  ::std::string* mutable_ini_file();
  ::std::string* release_ini_file();
  void set_allocated_ini_file(::std::string* ini_file);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_ini_file();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_ini_file(
      ::std::string* ini_file);

  // @@protoc_insertion_point(class_scope:carla_server.RequestNewEpisode)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::ArenaStringPtr ini_file_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_carla_5fserver_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SceneDescription : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:carla_server.SceneDescription) */ {
 public:
  SceneDescription();
  virtual ~SceneDescription();

  SceneDescription(const SceneDescription& from);

  inline SceneDescription& operator=(const SceneDescription& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SceneDescription(SceneDescription&& from) noexcept
    : SceneDescription() {
    *this = ::std::move(from);
  }

  inline SceneDescription& operator=(SceneDescription&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const SceneDescription& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SceneDescription* internal_default_instance() {
    return reinterpret_cast<const SceneDescription*>(
               &_SceneDescription_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void UnsafeArenaSwap(SceneDescription* other);
  void Swap(SceneDescription* other);
  friend void swap(SceneDescription& a, SceneDescription& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SceneDescription* New() const final {
    return CreateMaybeMessage<SceneDescription>(NULL);
  }

  SceneDescription* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SceneDescription>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SceneDescription& from);
  void MergeFrom(const SceneDescription& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SceneDescription* other);
  protected:
  explicit SceneDescription(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .carla_server.Transform player_start_spots = 1;
  int player_start_spots_size() const;
  void clear_player_start_spots();
  static const int kPlayerStartSpotsFieldNumber = 1;
  ::carla_server::Transform* mutable_player_start_spots(int index);
  ::google::protobuf::RepeatedPtrField< ::carla_server::Transform >*
      mutable_player_start_spots();
  const ::carla_server::Transform& player_start_spots(int index) const;
  ::carla_server::Transform* add_player_start_spots();
  const ::google::protobuf::RepeatedPtrField< ::carla_server::Transform >&
      player_start_spots() const;

  // repeated .carla_server.Sensor sensors = 2;
  int sensors_size() const;
  void clear_sensors();
  static const int kSensorsFieldNumber = 2;
  ::carla_server::Sensor* mutable_sensors(int index);
  ::google::protobuf::RepeatedPtrField< ::carla_server::Sensor >*
      mutable_sensors();
  const ::carla_server::Sensor& sensors(int index) const;
  ::carla_server::Sensor* add_sensors();
  const ::google::protobuf::RepeatedPtrField< ::carla_server::Sensor >&
      sensors() const;

  // string map_name = 3;
  void clear_map_name();
  static const int kMapNameFieldNumber = 3;
  const ::std::string& map_name() const;
  void set_map_name(const ::std::string& value);
  #if LANG_CXX11
  void set_map_name(::std::string&& value);
  #endif
  void set_map_name(const char* value);
  void set_map_name(const char* value, size_t size);
  ::std::string* mutable_map_name();
  ::std::string* release_map_name();
  void set_allocated_map_name(::std::string* map_name);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_map_name();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_map_name(
      ::std::string* map_name);

  // @@protoc_insertion_point(class_scope:carla_server.SceneDescription)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::RepeatedPtrField< ::carla_server::Transform > player_start_spots_;
  ::google::protobuf::RepeatedPtrField< ::carla_server::Sensor > sensors_;
  ::google::protobuf::internal::ArenaStringPtr map_name_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_carla_5fserver_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EpisodeStart : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:carla_server.EpisodeStart) */ {
 public:
  EpisodeStart();
  virtual ~EpisodeStart();

  EpisodeStart(const EpisodeStart& from);

  inline EpisodeStart& operator=(const EpisodeStart& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EpisodeStart(EpisodeStart&& from) noexcept
    : EpisodeStart() {
    *this = ::std::move(from);
  }

  inline EpisodeStart& operator=(EpisodeStart&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const EpisodeStart& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EpisodeStart* internal_default_instance() {
    return reinterpret_cast<const EpisodeStart*>(
               &_EpisodeStart_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void UnsafeArenaSwap(EpisodeStart* other);
  void Swap(EpisodeStart* other);
  friend void swap(EpisodeStart& a, EpisodeStart& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EpisodeStart* New() const final {
    return CreateMaybeMessage<EpisodeStart>(NULL);
  }

  EpisodeStart* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EpisodeStart>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EpisodeStart& from);
  void MergeFrom(const EpisodeStart& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EpisodeStart* other);
  protected:
  explicit EpisodeStart(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 player_start_spot_index = 1;
  void clear_player_start_spot_index();
  static const int kPlayerStartSpotIndexFieldNumber = 1;
  ::google::protobuf::uint32 player_start_spot_index() const;
  void set_player_start_spot_index(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:carla_server.EpisodeStart)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::uint32 player_start_spot_index_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_carla_5fserver_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EpisodeReady : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:carla_server.EpisodeReady) */ {
 public:
  EpisodeReady();
  virtual ~EpisodeReady();

  EpisodeReady(const EpisodeReady& from);

  inline EpisodeReady& operator=(const EpisodeReady& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EpisodeReady(EpisodeReady&& from) noexcept
    : EpisodeReady() {
    *this = ::std::move(from);
  }

  inline EpisodeReady& operator=(EpisodeReady&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const EpisodeReady& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EpisodeReady* internal_default_instance() {
    return reinterpret_cast<const EpisodeReady*>(
               &_EpisodeReady_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void UnsafeArenaSwap(EpisodeReady* other);
  void Swap(EpisodeReady* other);
  friend void swap(EpisodeReady& a, EpisodeReady& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EpisodeReady* New() const final {
    return CreateMaybeMessage<EpisodeReady>(NULL);
  }

  EpisodeReady* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EpisodeReady>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EpisodeReady& from);
  void MergeFrom(const EpisodeReady& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EpisodeReady* other);
  protected:
  explicit EpisodeReady(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool ready = 1;
  void clear_ready();
  static const int kReadyFieldNumber = 1;
  bool ready() const;
  void set_ready(bool value);

  // @@protoc_insertion_point(class_scope:carla_server.EpisodeReady)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool ready_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_carla_5fserver_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Control : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:carla_server.Control) */ {
 public:
  Control();
  virtual ~Control();

  Control(const Control& from);

  inline Control& operator=(const Control& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Control(Control&& from) noexcept
    : Control() {
    *this = ::std::move(from);
  }

  inline Control& operator=(Control&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Control& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Control* internal_default_instance() {
    return reinterpret_cast<const Control*>(
               &_Control_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void UnsafeArenaSwap(Control* other);
  void Swap(Control* other);
  friend void swap(Control& a, Control& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Control* New() const final {
    return CreateMaybeMessage<Control>(NULL);
  }

  Control* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Control>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Control& from);
  void MergeFrom(const Control& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Control* other);
  protected:
  explicit Control(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float steer = 1;
  void clear_steer();
  static const int kSteerFieldNumber = 1;
  float steer() const;
  void set_steer(float value);

  // float throttle = 2;
  void clear_throttle();
  static const int kThrottleFieldNumber = 2;
  float throttle() const;
  void set_throttle(float value);

  // float brake = 3;
  void clear_brake();
  static const int kBrakeFieldNumber = 3;
  float brake() const;
  void set_brake(float value);

  // bool hand_brake = 4;
  void clear_hand_brake();
  static const int kHandBrakeFieldNumber = 4;
  bool hand_brake() const;
  void set_hand_brake(bool value);

  // bool reverse = 5;
  void clear_reverse();
  static const int kReverseFieldNumber = 5;
  bool reverse() const;
  void set_reverse(bool value);

  // @@protoc_insertion_point(class_scope:carla_server.Control)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float steer_;
  float throttle_;
  float brake_;
  bool hand_brake_;
  bool reverse_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_carla_5fserver_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Measurements_PlayerMeasurements : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:carla_server.Measurements.PlayerMeasurements) */ {
 public:
  Measurements_PlayerMeasurements();
  virtual ~Measurements_PlayerMeasurements();

  Measurements_PlayerMeasurements(const Measurements_PlayerMeasurements& from);

  inline Measurements_PlayerMeasurements& operator=(const Measurements_PlayerMeasurements& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Measurements_PlayerMeasurements(Measurements_PlayerMeasurements&& from) noexcept
    : Measurements_PlayerMeasurements() {
    *this = ::std::move(from);
  }

  inline Measurements_PlayerMeasurements& operator=(Measurements_PlayerMeasurements&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Measurements_PlayerMeasurements& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Measurements_PlayerMeasurements* internal_default_instance() {
    return reinterpret_cast<const Measurements_PlayerMeasurements*>(
               &_Measurements_PlayerMeasurements_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void UnsafeArenaSwap(Measurements_PlayerMeasurements* other);
  void Swap(Measurements_PlayerMeasurements* other);
  friend void swap(Measurements_PlayerMeasurements& a, Measurements_PlayerMeasurements& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Measurements_PlayerMeasurements* New() const final {
    return CreateMaybeMessage<Measurements_PlayerMeasurements>(NULL);
  }

  Measurements_PlayerMeasurements* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Measurements_PlayerMeasurements>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Measurements_PlayerMeasurements& from);
  void MergeFrom(const Measurements_PlayerMeasurements& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Measurements_PlayerMeasurements* other);
  protected:
  explicit Measurements_PlayerMeasurements(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .carla_server.Transform transform = 1;
  bool has_transform() const;
  void clear_transform();
  static const int kTransformFieldNumber = 1;
  private:
  const ::carla_server::Transform& _internal_transform() const;
  public:
  const ::carla_server::Transform& transform() const;
  ::carla_server::Transform* release_transform();
  ::carla_server::Transform* mutable_transform();
  void set_allocated_transform(::carla_server::Transform* transform);
  void unsafe_arena_set_allocated_transform(
      ::carla_server::Transform* transform);
  ::carla_server::Transform* unsafe_arena_release_transform();

  // .carla_server.Vector3D acceleration = 3;
  bool has_acceleration() const;
  void clear_acceleration();
  static const int kAccelerationFieldNumber = 3;
  private:
  const ::carla_server::Vector3D& _internal_acceleration() const;
  public:
  const ::carla_server::Vector3D& acceleration() const;
  ::carla_server::Vector3D* release_acceleration();
  ::carla_server::Vector3D* mutable_acceleration();
  void set_allocated_acceleration(::carla_server::Vector3D* acceleration);
  void unsafe_arena_set_allocated_acceleration(
      ::carla_server::Vector3D* acceleration);
  ::carla_server::Vector3D* unsafe_arena_release_acceleration();

  // .carla_server.Control autopilot_control = 10;
  bool has_autopilot_control() const;
  void clear_autopilot_control();
  static const int kAutopilotControlFieldNumber = 10;
  private:
  const ::carla_server::Control& _internal_autopilot_control() const;
  public:
  const ::carla_server::Control& autopilot_control() const;
  ::carla_server::Control* release_autopilot_control();
  ::carla_server::Control* mutable_autopilot_control();
  void set_allocated_autopilot_control(::carla_server::Control* autopilot_control);
  void unsafe_arena_set_allocated_autopilot_control(
      ::carla_server::Control* autopilot_control);
  ::carla_server::Control* unsafe_arena_release_autopilot_control();

  // .carla_server.BoundingBox bounding_box = 12;
  bool has_bounding_box() const;
  void clear_bounding_box();
  static const int kBoundingBoxFieldNumber = 12;
  private:
  const ::carla_server::BoundingBox& _internal_bounding_box() const;
  public:
  const ::carla_server::BoundingBox& bounding_box() const;
  ::carla_server::BoundingBox* release_bounding_box();
  ::carla_server::BoundingBox* mutable_bounding_box();
  void set_allocated_bounding_box(::carla_server::BoundingBox* bounding_box);
  void unsafe_arena_set_allocated_bounding_box(
      ::carla_server::BoundingBox* bounding_box);
  ::carla_server::BoundingBox* unsafe_arena_release_bounding_box();

  // float forward_speed = 4;
  void clear_forward_speed();
  static const int kForwardSpeedFieldNumber = 4;
  float forward_speed() const;
  void set_forward_speed(float value);

  // float collision_vehicles = 5;
  void clear_collision_vehicles();
  static const int kCollisionVehiclesFieldNumber = 5;
  float collision_vehicles() const;
  void set_collision_vehicles(float value);

  // float collision_pedestrians = 6;
  void clear_collision_pedestrians();
  static const int kCollisionPedestriansFieldNumber = 6;
  float collision_pedestrians() const;
  void set_collision_pedestrians(float value);

  // float collision_other = 7;
  void clear_collision_other();
  static const int kCollisionOtherFieldNumber = 7;
  float collision_other() const;
  void set_collision_other(float value);

  // float intersection_otherlane = 8;
  void clear_intersection_otherlane();
  static const int kIntersectionOtherlaneFieldNumber = 8;
  float intersection_otherlane() const;
  void set_intersection_otherlane(float value);

  // float intersection_offroad = 9;
  void clear_intersection_offroad();
  static const int kIntersectionOffroadFieldNumber = 9;
  float intersection_offroad() const;
  void set_intersection_offroad(float value);

  // @@protoc_insertion_point(class_scope:carla_server.Measurements.PlayerMeasurements)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::carla_server::Transform* transform_;
  ::carla_server::Vector3D* acceleration_;
  ::carla_server::Control* autopilot_control_;
  ::carla_server::BoundingBox* bounding_box_;
  float forward_speed_;
  float collision_vehicles_;
  float collision_pedestrians_;
  float collision_other_;
  float intersection_otherlane_;
  float intersection_offroad_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_carla_5fserver_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Measurements : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:carla_server.Measurements) */ {
 public:
  Measurements();
  virtual ~Measurements();

  Measurements(const Measurements& from);

  inline Measurements& operator=(const Measurements& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Measurements(Measurements&& from) noexcept
    : Measurements() {
    *this = ::std::move(from);
  }

  inline Measurements& operator=(Measurements&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Measurements& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Measurements* internal_default_instance() {
    return reinterpret_cast<const Measurements*>(
               &_Measurements_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void UnsafeArenaSwap(Measurements* other);
  void Swap(Measurements* other);
  friend void swap(Measurements& a, Measurements& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Measurements* New() const final {
    return CreateMaybeMessage<Measurements>(NULL);
  }

  Measurements* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Measurements>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Measurements& from);
  void MergeFrom(const Measurements& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Measurements* other);
  protected:
  explicit Measurements(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Measurements_PlayerMeasurements PlayerMeasurements;

  // accessors -------------------------------------------------------

  // repeated .carla_server.Agent non_player_agents = 4;
  int non_player_agents_size() const;
  void clear_non_player_agents();
  static const int kNonPlayerAgentsFieldNumber = 4;
  ::carla_server::Agent* mutable_non_player_agents(int index);
  ::google::protobuf::RepeatedPtrField< ::carla_server::Agent >*
      mutable_non_player_agents();
  const ::carla_server::Agent& non_player_agents(int index) const;
  ::carla_server::Agent* add_non_player_agents();
  const ::google::protobuf::RepeatedPtrField< ::carla_server::Agent >&
      non_player_agents() const;

  // .carla_server.Measurements.PlayerMeasurements player_measurements = 3;
  bool has_player_measurements() const;
  void clear_player_measurements();
  static const int kPlayerMeasurementsFieldNumber = 3;
  private:
  const ::carla_server::Measurements_PlayerMeasurements& _internal_player_measurements() const;
  public:
  const ::carla_server::Measurements_PlayerMeasurements& player_measurements() const;
  ::carla_server::Measurements_PlayerMeasurements* release_player_measurements();
  ::carla_server::Measurements_PlayerMeasurements* mutable_player_measurements();
  void set_allocated_player_measurements(::carla_server::Measurements_PlayerMeasurements* player_measurements);
  void unsafe_arena_set_allocated_player_measurements(
      ::carla_server::Measurements_PlayerMeasurements* player_measurements);
  ::carla_server::Measurements_PlayerMeasurements* unsafe_arena_release_player_measurements();

  // uint32 platform_timestamp = 1;
  void clear_platform_timestamp();
  static const int kPlatformTimestampFieldNumber = 1;
  ::google::protobuf::uint32 platform_timestamp() const;
  void set_platform_timestamp(::google::protobuf::uint32 value);

  // uint32 game_timestamp = 2;
  void clear_game_timestamp();
  static const int kGameTimestampFieldNumber = 2;
  ::google::protobuf::uint32 game_timestamp() const;
  void set_game_timestamp(::google::protobuf::uint32 value);

  // uint64 frame_number = 5;
  void clear_frame_number();
  static const int kFrameNumberFieldNumber = 5;
  ::google::protobuf::uint64 frame_number() const;
  void set_frame_number(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:carla_server.Measurements)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::RepeatedPtrField< ::carla_server::Agent > non_player_agents_;
  ::carla_server::Measurements_PlayerMeasurements* player_measurements_;
  ::google::protobuf::uint32 platform_timestamp_;
  ::google::protobuf::uint32 game_timestamp_;
  ::google::protobuf::uint64 frame_number_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_carla_5fserver_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Vector3D

// float x = 1;
inline void Vector3D::clear_x() {
  x_ = 0;
}
inline float Vector3D::x() const {
  // @@protoc_insertion_point(field_get:carla_server.Vector3D.x)
  return x_;
}
inline void Vector3D::set_x(float value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:carla_server.Vector3D.x)
}

// float y = 2;
inline void Vector3D::clear_y() {
  y_ = 0;
}
inline float Vector3D::y() const {
  // @@protoc_insertion_point(field_get:carla_server.Vector3D.y)
  return y_;
}
inline void Vector3D::set_y(float value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:carla_server.Vector3D.y)
}

// float z = 3;
inline void Vector3D::clear_z() {
  z_ = 0;
}
inline float Vector3D::z() const {
  // @@protoc_insertion_point(field_get:carla_server.Vector3D.z)
  return z_;
}
inline void Vector3D::set_z(float value) {
  
  z_ = value;
  // @@protoc_insertion_point(field_set:carla_server.Vector3D.z)
}

// -------------------------------------------------------------------

// Rotation3D

// float pitch = 1;
inline void Rotation3D::clear_pitch() {
  pitch_ = 0;
}
inline float Rotation3D::pitch() const {
  // @@protoc_insertion_point(field_get:carla_server.Rotation3D.pitch)
  return pitch_;
}
inline void Rotation3D::set_pitch(float value) {
  
  pitch_ = value;
  // @@protoc_insertion_point(field_set:carla_server.Rotation3D.pitch)
}

// float yaw = 2;
inline void Rotation3D::clear_yaw() {
  yaw_ = 0;
}
inline float Rotation3D::yaw() const {
  // @@protoc_insertion_point(field_get:carla_server.Rotation3D.yaw)
  return yaw_;
}
inline void Rotation3D::set_yaw(float value) {
  
  yaw_ = value;
  // @@protoc_insertion_point(field_set:carla_server.Rotation3D.yaw)
}

// float roll = 3;
inline void Rotation3D::clear_roll() {
  roll_ = 0;
}
inline float Rotation3D::roll() const {
  // @@protoc_insertion_point(field_get:carla_server.Rotation3D.roll)
  return roll_;
}
inline void Rotation3D::set_roll(float value) {
  
  roll_ = value;
  // @@protoc_insertion_point(field_set:carla_server.Rotation3D.roll)
}

// -------------------------------------------------------------------

// Transform

// .carla_server.Vector3D location = 1;
inline bool Transform::has_location() const {
  return this != internal_default_instance() && location_ != NULL;
}
inline void Transform::clear_location() {
  if (GetArenaNoVirtual() == NULL && location_ != NULL) {
    delete location_;
  }
  location_ = NULL;
}
inline const ::carla_server::Vector3D& Transform::_internal_location() const {
  return *location_;
}
inline const ::carla_server::Vector3D& Transform::location() const {
  const ::carla_server::Vector3D* p = location_;
  // @@protoc_insertion_point(field_get:carla_server.Transform.location)
  return p != NULL ? *p : *reinterpret_cast<const ::carla_server::Vector3D*>(
      &::carla_server::_Vector3D_default_instance_);
}
inline ::carla_server::Vector3D* Transform::release_location() {
  // @@protoc_insertion_point(field_release:carla_server.Transform.location)
  
  ::carla_server::Vector3D* temp = location_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  location_ = NULL;
  return temp;
}
inline ::carla_server::Vector3D* Transform::unsafe_arena_release_location() {
  // @@protoc_insertion_point(field_unsafe_arena_release:carla_server.Transform.location)
  
  ::carla_server::Vector3D* temp = location_;
  location_ = NULL;
  return temp;
}
inline ::carla_server::Vector3D* Transform::mutable_location() {
  
  if (location_ == NULL) {
    auto* p = CreateMaybeMessage<::carla_server::Vector3D>(GetArenaNoVirtual());
    location_ = p;
  }
  // @@protoc_insertion_point(field_mutable:carla_server.Transform.location)
  return location_;
}
inline void Transform::set_allocated_location(::carla_server::Vector3D* location) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete location_;
  }
  if (location) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(location);
    if (message_arena != submessage_arena) {
      location = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, location, submessage_arena);
    }
    
  } else {
    
  }
  location_ = location;
  // @@protoc_insertion_point(field_set_allocated:carla_server.Transform.location)
}

// .carla_server.Vector3D orientation = 2 [deprecated = true];
inline bool Transform::has_orientation() const {
  return this != internal_default_instance() && orientation_ != NULL;
}
inline void Transform::clear_orientation() {
  if (GetArenaNoVirtual() == NULL && orientation_ != NULL) {
    delete orientation_;
  }
  orientation_ = NULL;
}
inline const ::carla_server::Vector3D& Transform::_internal_orientation() const {
  return *orientation_;
}
inline const ::carla_server::Vector3D& Transform::orientation() const {
  const ::carla_server::Vector3D* p = orientation_;
  // @@protoc_insertion_point(field_get:carla_server.Transform.orientation)
  return p != NULL ? *p : *reinterpret_cast<const ::carla_server::Vector3D*>(
      &::carla_server::_Vector3D_default_instance_);
}
inline ::carla_server::Vector3D* Transform::release_orientation() {
  // @@protoc_insertion_point(field_release:carla_server.Transform.orientation)
  
  ::carla_server::Vector3D* temp = orientation_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  orientation_ = NULL;
  return temp;
}
inline ::carla_server::Vector3D* Transform::unsafe_arena_release_orientation() {
  // @@protoc_insertion_point(field_unsafe_arena_release:carla_server.Transform.orientation)
  
  ::carla_server::Vector3D* temp = orientation_;
  orientation_ = NULL;
  return temp;
}
inline ::carla_server::Vector3D* Transform::mutable_orientation() {
  
  if (orientation_ == NULL) {
    auto* p = CreateMaybeMessage<::carla_server::Vector3D>(GetArenaNoVirtual());
    orientation_ = p;
  }
  // @@protoc_insertion_point(field_mutable:carla_server.Transform.orientation)
  return orientation_;
}
inline void Transform::set_allocated_orientation(::carla_server::Vector3D* orientation) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete orientation_;
  }
  if (orientation) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(orientation);
    if (message_arena != submessage_arena) {
      orientation = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, orientation, submessage_arena);
    }
    
  } else {
    
  }
  orientation_ = orientation;
  // @@protoc_insertion_point(field_set_allocated:carla_server.Transform.orientation)
}

// .carla_server.Rotation3D rotation = 3;
inline bool Transform::has_rotation() const {
  return this != internal_default_instance() && rotation_ != NULL;
}
inline void Transform::clear_rotation() {
  if (GetArenaNoVirtual() == NULL && rotation_ != NULL) {
    delete rotation_;
  }
  rotation_ = NULL;
}
inline const ::carla_server::Rotation3D& Transform::_internal_rotation() const {
  return *rotation_;
}
inline const ::carla_server::Rotation3D& Transform::rotation() const {
  const ::carla_server::Rotation3D* p = rotation_;
  // @@protoc_insertion_point(field_get:carla_server.Transform.rotation)
  return p != NULL ? *p : *reinterpret_cast<const ::carla_server::Rotation3D*>(
      &::carla_server::_Rotation3D_default_instance_);
}
inline ::carla_server::Rotation3D* Transform::release_rotation() {
  // @@protoc_insertion_point(field_release:carla_server.Transform.rotation)
  
  ::carla_server::Rotation3D* temp = rotation_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  rotation_ = NULL;
  return temp;
}
inline ::carla_server::Rotation3D* Transform::unsafe_arena_release_rotation() {
  // @@protoc_insertion_point(field_unsafe_arena_release:carla_server.Transform.rotation)
  
  ::carla_server::Rotation3D* temp = rotation_;
  rotation_ = NULL;
  return temp;
}
inline ::carla_server::Rotation3D* Transform::mutable_rotation() {
  
  if (rotation_ == NULL) {
    auto* p = CreateMaybeMessage<::carla_server::Rotation3D>(GetArenaNoVirtual());
    rotation_ = p;
  }
  // @@protoc_insertion_point(field_mutable:carla_server.Transform.rotation)
  return rotation_;
}
inline void Transform::set_allocated_rotation(::carla_server::Rotation3D* rotation) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete rotation_;
  }
  if (rotation) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(rotation);
    if (message_arena != submessage_arena) {
      rotation = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, rotation, submessage_arena);
    }
    
  } else {
    
  }
  rotation_ = rotation;
  // @@protoc_insertion_point(field_set_allocated:carla_server.Transform.rotation)
}

// -------------------------------------------------------------------

// BoundingBox

// .carla_server.Transform transform = 1;
inline bool BoundingBox::has_transform() const {
  return this != internal_default_instance() && transform_ != NULL;
}
inline void BoundingBox::clear_transform() {
  if (GetArenaNoVirtual() == NULL && transform_ != NULL) {
    delete transform_;
  }
  transform_ = NULL;
}
inline const ::carla_server::Transform& BoundingBox::_internal_transform() const {
  return *transform_;
}
inline const ::carla_server::Transform& BoundingBox::transform() const {
  const ::carla_server::Transform* p = transform_;
  // @@protoc_insertion_point(field_get:carla_server.BoundingBox.transform)
  return p != NULL ? *p : *reinterpret_cast<const ::carla_server::Transform*>(
      &::carla_server::_Transform_default_instance_);
}
inline ::carla_server::Transform* BoundingBox::release_transform() {
  // @@protoc_insertion_point(field_release:carla_server.BoundingBox.transform)
  
  ::carla_server::Transform* temp = transform_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  transform_ = NULL;
  return temp;
}
inline ::carla_server::Transform* BoundingBox::unsafe_arena_release_transform() {
  // @@protoc_insertion_point(field_unsafe_arena_release:carla_server.BoundingBox.transform)
  
  ::carla_server::Transform* temp = transform_;
  transform_ = NULL;
  return temp;
}
inline ::carla_server::Transform* BoundingBox::mutable_transform() {
  
  if (transform_ == NULL) {
    auto* p = CreateMaybeMessage<::carla_server::Transform>(GetArenaNoVirtual());
    transform_ = p;
  }
  // @@protoc_insertion_point(field_mutable:carla_server.BoundingBox.transform)
  return transform_;
}
inline void BoundingBox::set_allocated_transform(::carla_server::Transform* transform) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete transform_;
  }
  if (transform) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(transform);
    if (message_arena != submessage_arena) {
      transform = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, transform, submessage_arena);
    }
    
  } else {
    
  }
  transform_ = transform;
  // @@protoc_insertion_point(field_set_allocated:carla_server.BoundingBox.transform)
}

// .carla_server.Vector3D extent = 2;
inline bool BoundingBox::has_extent() const {
  return this != internal_default_instance() && extent_ != NULL;
}
inline void BoundingBox::clear_extent() {
  if (GetArenaNoVirtual() == NULL && extent_ != NULL) {
    delete extent_;
  }
  extent_ = NULL;
}
inline const ::carla_server::Vector3D& BoundingBox::_internal_extent() const {
  return *extent_;
}
inline const ::carla_server::Vector3D& BoundingBox::extent() const {
  const ::carla_server::Vector3D* p = extent_;
  // @@protoc_insertion_point(field_get:carla_server.BoundingBox.extent)
  return p != NULL ? *p : *reinterpret_cast<const ::carla_server::Vector3D*>(
      &::carla_server::_Vector3D_default_instance_);
}
inline ::carla_server::Vector3D* BoundingBox::release_extent() {
  // @@protoc_insertion_point(field_release:carla_server.BoundingBox.extent)
  
  ::carla_server::Vector3D* temp = extent_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  extent_ = NULL;
  return temp;
}
inline ::carla_server::Vector3D* BoundingBox::unsafe_arena_release_extent() {
  // @@protoc_insertion_point(field_unsafe_arena_release:carla_server.BoundingBox.extent)
  
  ::carla_server::Vector3D* temp = extent_;
  extent_ = NULL;
  return temp;
}
inline ::carla_server::Vector3D* BoundingBox::mutable_extent() {
  
  if (extent_ == NULL) {
    auto* p = CreateMaybeMessage<::carla_server::Vector3D>(GetArenaNoVirtual());
    extent_ = p;
  }
  // @@protoc_insertion_point(field_mutable:carla_server.BoundingBox.extent)
  return extent_;
}
inline void BoundingBox::set_allocated_extent(::carla_server::Vector3D* extent) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete extent_;
  }
  if (extent) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(extent);
    if (message_arena != submessage_arena) {
      extent = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, extent, submessage_arena);
    }
    
  } else {
    
  }
  extent_ = extent;
  // @@protoc_insertion_point(field_set_allocated:carla_server.BoundingBox.extent)
}

// -------------------------------------------------------------------

// Sensor

// fixed32 id = 1;
inline void Sensor::clear_id() {
  id_ = 0u;
}
inline ::google::protobuf::uint32 Sensor::id() const {
  // @@protoc_insertion_point(field_get:carla_server.Sensor.id)
  return id_;
}
inline void Sensor::set_id(::google::protobuf::uint32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:carla_server.Sensor.id)
}

// .carla_server.Sensor.Type type = 2;
inline void Sensor::clear_type() {
  type_ = 0;
}
inline ::carla_server::Sensor_Type Sensor::type() const {
  // @@protoc_insertion_point(field_get:carla_server.Sensor.type)
  return static_cast< ::carla_server::Sensor_Type >(type_);
}
inline void Sensor::set_type(::carla_server::Sensor_Type value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:carla_server.Sensor.type)
}

// string name = 3;
inline void Sensor::clear_name() {
  name_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline const ::std::string& Sensor::name() const {
  // @@protoc_insertion_point(field_get:carla_server.Sensor.name)
  return name_.Get();
}
inline void Sensor::set_name(const ::std::string& value) {
  
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:carla_server.Sensor.name)
}
#if LANG_CXX11
inline void Sensor::set_name(::std::string&& value) {
  
  name_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:carla_server.Sensor.name)
}
#endif
inline void Sensor::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:carla_server.Sensor.name)
}
inline void Sensor::set_name(const char* value,
    size_t size) {
  
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:carla_server.Sensor.name)
}
inline ::std::string* Sensor::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:carla_server.Sensor.name)
  return name_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* Sensor::release_name() {
  // @@protoc_insertion_point(field_release:carla_server.Sensor.name)
  
  return name_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void Sensor::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:carla_server.Sensor.name)
}
inline ::std::string* Sensor::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:carla_server.Sensor.name)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  
  return name_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void Sensor::unsafe_arena_set_allocated_name(
    ::std::string* name) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (name != NULL) {
    
  } else {
    
  }
  name_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      name, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:carla_server.Sensor.name)
}

// -------------------------------------------------------------------

// Vehicle

// .carla_server.Transform transform = 1;
inline bool Vehicle::has_transform() const {
  return this != internal_default_instance() && transform_ != NULL;
}
inline void Vehicle::clear_transform() {
  if (GetArenaNoVirtual() == NULL && transform_ != NULL) {
    delete transform_;
  }
  transform_ = NULL;
}
inline const ::carla_server::Transform& Vehicle::_internal_transform() const {
  return *transform_;
}
inline const ::carla_server::Transform& Vehicle::transform() const {
  const ::carla_server::Transform* p = transform_;
  // @@protoc_insertion_point(field_get:carla_server.Vehicle.transform)
  return p != NULL ? *p : *reinterpret_cast<const ::carla_server::Transform*>(
      &::carla_server::_Transform_default_instance_);
}
inline ::carla_server::Transform* Vehicle::release_transform() {
  // @@protoc_insertion_point(field_release:carla_server.Vehicle.transform)
  
  ::carla_server::Transform* temp = transform_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  transform_ = NULL;
  return temp;
}
inline ::carla_server::Transform* Vehicle::unsafe_arena_release_transform() {
  // @@protoc_insertion_point(field_unsafe_arena_release:carla_server.Vehicle.transform)
  
  ::carla_server::Transform* temp = transform_;
  transform_ = NULL;
  return temp;
}
inline ::carla_server::Transform* Vehicle::mutable_transform() {
  
  if (transform_ == NULL) {
    auto* p = CreateMaybeMessage<::carla_server::Transform>(GetArenaNoVirtual());
    transform_ = p;
  }
  // @@protoc_insertion_point(field_mutable:carla_server.Vehicle.transform)
  return transform_;
}
inline void Vehicle::set_allocated_transform(::carla_server::Transform* transform) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete transform_;
  }
  if (transform) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(transform);
    if (message_arena != submessage_arena) {
      transform = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, transform, submessage_arena);
    }
    
  } else {
    
  }
  transform_ = transform;
  // @@protoc_insertion_point(field_set_allocated:carla_server.Vehicle.transform)
}

// .carla_server.BoundingBox bounding_box = 4;
inline bool Vehicle::has_bounding_box() const {
  return this != internal_default_instance() && bounding_box_ != NULL;
}
inline void Vehicle::clear_bounding_box() {
  if (GetArenaNoVirtual() == NULL && bounding_box_ != NULL) {
    delete bounding_box_;
  }
  bounding_box_ = NULL;
}
inline const ::carla_server::BoundingBox& Vehicle::_internal_bounding_box() const {
  return *bounding_box_;
}
inline const ::carla_server::BoundingBox& Vehicle::bounding_box() const {
  const ::carla_server::BoundingBox* p = bounding_box_;
  // @@protoc_insertion_point(field_get:carla_server.Vehicle.bounding_box)
  return p != NULL ? *p : *reinterpret_cast<const ::carla_server::BoundingBox*>(
      &::carla_server::_BoundingBox_default_instance_);
}
inline ::carla_server::BoundingBox* Vehicle::release_bounding_box() {
  // @@protoc_insertion_point(field_release:carla_server.Vehicle.bounding_box)
  
  ::carla_server::BoundingBox* temp = bounding_box_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  bounding_box_ = NULL;
  return temp;
}
inline ::carla_server::BoundingBox* Vehicle::unsafe_arena_release_bounding_box() {
  // @@protoc_insertion_point(field_unsafe_arena_release:carla_server.Vehicle.bounding_box)
  
  ::carla_server::BoundingBox* temp = bounding_box_;
  bounding_box_ = NULL;
  return temp;
}
inline ::carla_server::BoundingBox* Vehicle::mutable_bounding_box() {
  
  if (bounding_box_ == NULL) {
    auto* p = CreateMaybeMessage<::carla_server::BoundingBox>(GetArenaNoVirtual());
    bounding_box_ = p;
  }
  // @@protoc_insertion_point(field_mutable:carla_server.Vehicle.bounding_box)
  return bounding_box_;
}
inline void Vehicle::set_allocated_bounding_box(::carla_server::BoundingBox* bounding_box) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete bounding_box_;
  }
  if (bounding_box) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(bounding_box);
    if (message_arena != submessage_arena) {
      bounding_box = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, bounding_box, submessage_arena);
    }
    
  } else {
    
  }
  bounding_box_ = bounding_box;
  // @@protoc_insertion_point(field_set_allocated:carla_server.Vehicle.bounding_box)
}

// float forward_speed = 3;
inline void Vehicle::clear_forward_speed() {
  forward_speed_ = 0;
}
inline float Vehicle::forward_speed() const {
  // @@protoc_insertion_point(field_get:carla_server.Vehicle.forward_speed)
  return forward_speed_;
}
inline void Vehicle::set_forward_speed(float value) {
  
  forward_speed_ = value;
  // @@protoc_insertion_point(field_set:carla_server.Vehicle.forward_speed)
}

// -------------------------------------------------------------------

// Pedestrian

// .carla_server.Transform transform = 1;
inline bool Pedestrian::has_transform() const {
  return this != internal_default_instance() && transform_ != NULL;
}
inline void Pedestrian::clear_transform() {
  if (GetArenaNoVirtual() == NULL && transform_ != NULL) {
    delete transform_;
  }
  transform_ = NULL;
}
inline const ::carla_server::Transform& Pedestrian::_internal_transform() const {
  return *transform_;
}
inline const ::carla_server::Transform& Pedestrian::transform() const {
  const ::carla_server::Transform* p = transform_;
  // @@protoc_insertion_point(field_get:carla_server.Pedestrian.transform)
  return p != NULL ? *p : *reinterpret_cast<const ::carla_server::Transform*>(
      &::carla_server::_Transform_default_instance_);
}
inline ::carla_server::Transform* Pedestrian::release_transform() {
  // @@protoc_insertion_point(field_release:carla_server.Pedestrian.transform)
  
  ::carla_server::Transform* temp = transform_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  transform_ = NULL;
  return temp;
}
inline ::carla_server::Transform* Pedestrian::unsafe_arena_release_transform() {
  // @@protoc_insertion_point(field_unsafe_arena_release:carla_server.Pedestrian.transform)
  
  ::carla_server::Transform* temp = transform_;
  transform_ = NULL;
  return temp;
}
inline ::carla_server::Transform* Pedestrian::mutable_transform() {
  
  if (transform_ == NULL) {
    auto* p = CreateMaybeMessage<::carla_server::Transform>(GetArenaNoVirtual());
    transform_ = p;
  }
  // @@protoc_insertion_point(field_mutable:carla_server.Pedestrian.transform)
  return transform_;
}
inline void Pedestrian::set_allocated_transform(::carla_server::Transform* transform) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete transform_;
  }
  if (transform) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(transform);
    if (message_arena != submessage_arena) {
      transform = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, transform, submessage_arena);
    }
    
  } else {
    
  }
  transform_ = transform;
  // @@protoc_insertion_point(field_set_allocated:carla_server.Pedestrian.transform)
}

// .carla_server.BoundingBox bounding_box = 4;
inline bool Pedestrian::has_bounding_box() const {
  return this != internal_default_instance() && bounding_box_ != NULL;
}
inline void Pedestrian::clear_bounding_box() {
  if (GetArenaNoVirtual() == NULL && bounding_box_ != NULL) {
    delete bounding_box_;
  }
  bounding_box_ = NULL;
}
inline const ::carla_server::BoundingBox& Pedestrian::_internal_bounding_box() const {
  return *bounding_box_;
}
inline const ::carla_server::BoundingBox& Pedestrian::bounding_box() const {
  const ::carla_server::BoundingBox* p = bounding_box_;
  // @@protoc_insertion_point(field_get:carla_server.Pedestrian.bounding_box)
  return p != NULL ? *p : *reinterpret_cast<const ::carla_server::BoundingBox*>(
      &::carla_server::_BoundingBox_default_instance_);
}
inline ::carla_server::BoundingBox* Pedestrian::release_bounding_box() {
  // @@protoc_insertion_point(field_release:carla_server.Pedestrian.bounding_box)
  
  ::carla_server::BoundingBox* temp = bounding_box_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  bounding_box_ = NULL;
  return temp;
}
inline ::carla_server::BoundingBox* Pedestrian::unsafe_arena_release_bounding_box() {
  // @@protoc_insertion_point(field_unsafe_arena_release:carla_server.Pedestrian.bounding_box)
  
  ::carla_server::BoundingBox* temp = bounding_box_;
  bounding_box_ = NULL;
  return temp;
}
inline ::carla_server::BoundingBox* Pedestrian::mutable_bounding_box() {
  
  if (bounding_box_ == NULL) {
    auto* p = CreateMaybeMessage<::carla_server::BoundingBox>(GetArenaNoVirtual());
    bounding_box_ = p;
  }
  // @@protoc_insertion_point(field_mutable:carla_server.Pedestrian.bounding_box)
  return bounding_box_;
}
inline void Pedestrian::set_allocated_bounding_box(::carla_server::BoundingBox* bounding_box) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete bounding_box_;
  }
  if (bounding_box) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(bounding_box);
    if (message_arena != submessage_arena) {
      bounding_box = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, bounding_box, submessage_arena);
    }
    
  } else {
    
  }
  bounding_box_ = bounding_box;
  // @@protoc_insertion_point(field_set_allocated:carla_server.Pedestrian.bounding_box)
}

// float forward_speed = 3;
inline void Pedestrian::clear_forward_speed() {
  forward_speed_ = 0;
}
inline float Pedestrian::forward_speed() const {
  // @@protoc_insertion_point(field_get:carla_server.Pedestrian.forward_speed)
  return forward_speed_;
}
inline void Pedestrian::set_forward_speed(float value) {
  
  forward_speed_ = value;
  // @@protoc_insertion_point(field_set:carla_server.Pedestrian.forward_speed)
}

// -------------------------------------------------------------------

// TrafficLight

// .carla_server.Transform transform = 1;
inline bool TrafficLight::has_transform() const {
  return this != internal_default_instance() && transform_ != NULL;
}
inline void TrafficLight::clear_transform() {
  if (GetArenaNoVirtual() == NULL && transform_ != NULL) {
    delete transform_;
  }
  transform_ = NULL;
}
inline const ::carla_server::Transform& TrafficLight::_internal_transform() const {
  return *transform_;
}
inline const ::carla_server::Transform& TrafficLight::transform() const {
  const ::carla_server::Transform* p = transform_;
  // @@protoc_insertion_point(field_get:carla_server.TrafficLight.transform)
  return p != NULL ? *p : *reinterpret_cast<const ::carla_server::Transform*>(
      &::carla_server::_Transform_default_instance_);
}
inline ::carla_server::Transform* TrafficLight::release_transform() {
  // @@protoc_insertion_point(field_release:carla_server.TrafficLight.transform)
  
  ::carla_server::Transform* temp = transform_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  transform_ = NULL;
  return temp;
}
inline ::carla_server::Transform* TrafficLight::unsafe_arena_release_transform() {
  // @@protoc_insertion_point(field_unsafe_arena_release:carla_server.TrafficLight.transform)
  
  ::carla_server::Transform* temp = transform_;
  transform_ = NULL;
  return temp;
}
inline ::carla_server::Transform* TrafficLight::mutable_transform() {
  
  if (transform_ == NULL) {
    auto* p = CreateMaybeMessage<::carla_server::Transform>(GetArenaNoVirtual());
    transform_ = p;
  }
  // @@protoc_insertion_point(field_mutable:carla_server.TrafficLight.transform)
  return transform_;
}
inline void TrafficLight::set_allocated_transform(::carla_server::Transform* transform) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete transform_;
  }
  if (transform) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(transform);
    if (message_arena != submessage_arena) {
      transform = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, transform, submessage_arena);
    }
    
  } else {
    
  }
  transform_ = transform;
  // @@protoc_insertion_point(field_set_allocated:carla_server.TrafficLight.transform)
}

// .carla_server.TrafficLight.State state = 2;
inline void TrafficLight::clear_state() {
  state_ = 0;
}
inline ::carla_server::TrafficLight_State TrafficLight::state() const {
  // @@protoc_insertion_point(field_get:carla_server.TrafficLight.state)
  return static_cast< ::carla_server::TrafficLight_State >(state_);
}
inline void TrafficLight::set_state(::carla_server::TrafficLight_State value) {
  
  state_ = value;
  // @@protoc_insertion_point(field_set:carla_server.TrafficLight.state)
}

// -------------------------------------------------------------------

// SpeedLimitSign

// .carla_server.Transform transform = 1;
inline bool SpeedLimitSign::has_transform() const {
  return this != internal_default_instance() && transform_ != NULL;
}
inline void SpeedLimitSign::clear_transform() {
  if (GetArenaNoVirtual() == NULL && transform_ != NULL) {
    delete transform_;
  }
  transform_ = NULL;
}
inline const ::carla_server::Transform& SpeedLimitSign::_internal_transform() const {
  return *transform_;
}
inline const ::carla_server::Transform& SpeedLimitSign::transform() const {
  const ::carla_server::Transform* p = transform_;
  // @@protoc_insertion_point(field_get:carla_server.SpeedLimitSign.transform)
  return p != NULL ? *p : *reinterpret_cast<const ::carla_server::Transform*>(
      &::carla_server::_Transform_default_instance_);
}
inline ::carla_server::Transform* SpeedLimitSign::release_transform() {
  // @@protoc_insertion_point(field_release:carla_server.SpeedLimitSign.transform)
  
  ::carla_server::Transform* temp = transform_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  transform_ = NULL;
  return temp;
}
inline ::carla_server::Transform* SpeedLimitSign::unsafe_arena_release_transform() {
  // @@protoc_insertion_point(field_unsafe_arena_release:carla_server.SpeedLimitSign.transform)
  
  ::carla_server::Transform* temp = transform_;
  transform_ = NULL;
  return temp;
}
inline ::carla_server::Transform* SpeedLimitSign::mutable_transform() {
  
  if (transform_ == NULL) {
    auto* p = CreateMaybeMessage<::carla_server::Transform>(GetArenaNoVirtual());
    transform_ = p;
  }
  // @@protoc_insertion_point(field_mutable:carla_server.SpeedLimitSign.transform)
  return transform_;
}
inline void SpeedLimitSign::set_allocated_transform(::carla_server::Transform* transform) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete transform_;
  }
  if (transform) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(transform);
    if (message_arena != submessage_arena) {
      transform = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, transform, submessage_arena);
    }
    
  } else {
    
  }
  transform_ = transform;
  // @@protoc_insertion_point(field_set_allocated:carla_server.SpeedLimitSign.transform)
}

// float speed_limit = 2;
inline void SpeedLimitSign::clear_speed_limit() {
  speed_limit_ = 0;
}
inline float SpeedLimitSign::speed_limit() const {
  // @@protoc_insertion_point(field_get:carla_server.SpeedLimitSign.speed_limit)
  return speed_limit_;
}
inline void SpeedLimitSign::set_speed_limit(float value) {
  
  speed_limit_ = value;
  // @@protoc_insertion_point(field_set:carla_server.SpeedLimitSign.speed_limit)
}

// -------------------------------------------------------------------

// Agent

// fixed32 id = 1;
inline void Agent::clear_id() {
  id_ = 0u;
}
inline ::google::protobuf::uint32 Agent::id() const {
  // @@protoc_insertion_point(field_get:carla_server.Agent.id)
  return id_;
}
inline void Agent::set_id(::google::protobuf::uint32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:carla_server.Agent.id)
}

// .carla_server.Vehicle vehicle = 2;
inline bool Agent::has_vehicle() const {
  return agent_case() == kVehicle;
}
inline void Agent::set_has_vehicle() {
  _oneof_case_[0] = kVehicle;
}
inline void Agent::clear_vehicle() {
  if (has_vehicle()) {
    if (GetArenaNoVirtual() == NULL) {
      delete agent_.vehicle_;
    }
    clear_has_agent();
  }
}
inline const ::carla_server::Vehicle& Agent::_internal_vehicle() const {
  return *agent_.vehicle_;
}
inline ::carla_server::Vehicle* Agent::release_vehicle() {
  // @@protoc_insertion_point(field_release:carla_server.Agent.vehicle)
  if (has_vehicle()) {
    clear_has_agent();
      ::carla_server::Vehicle* temp = agent_.vehicle_;
    if (GetArenaNoVirtual() != NULL) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    agent_.vehicle_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::carla_server::Vehicle& Agent::vehicle() const {
  // @@protoc_insertion_point(field_get:carla_server.Agent.vehicle)
  return has_vehicle()
      ? *agent_.vehicle_
      : *reinterpret_cast< ::carla_server::Vehicle*>(&::carla_server::_Vehicle_default_instance_);
}
inline ::carla_server::Vehicle* Agent::unsafe_arena_release_vehicle() {
  // @@protoc_insertion_point(field_unsafe_arena_release:carla_server.Agent.vehicle)
  if (has_vehicle()) {
    clear_has_agent();
    ::carla_server::Vehicle* temp = agent_.vehicle_;
    agent_.vehicle_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Agent::unsafe_arena_set_allocated_vehicle(::carla_server::Vehicle* vehicle) {
  clear_agent();
  if (vehicle) {
    set_has_vehicle();
    agent_.vehicle_ = vehicle;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:carla_server.Agent.vehicle)
}
inline ::carla_server::Vehicle* Agent::mutable_vehicle() {
  if (!has_vehicle()) {
    clear_agent();
    set_has_vehicle();
    agent_.vehicle_ = CreateMaybeMessage< ::carla_server::Vehicle >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:carla_server.Agent.vehicle)
  return agent_.vehicle_;
}

// .carla_server.Pedestrian pedestrian = 3;
inline bool Agent::has_pedestrian() const {
  return agent_case() == kPedestrian;
}
inline void Agent::set_has_pedestrian() {
  _oneof_case_[0] = kPedestrian;
}
inline void Agent::clear_pedestrian() {
  if (has_pedestrian()) {
    if (GetArenaNoVirtual() == NULL) {
      delete agent_.pedestrian_;
    }
    clear_has_agent();
  }
}
inline const ::carla_server::Pedestrian& Agent::_internal_pedestrian() const {
  return *agent_.pedestrian_;
}
inline ::carla_server::Pedestrian* Agent::release_pedestrian() {
  // @@protoc_insertion_point(field_release:carla_server.Agent.pedestrian)
  if (has_pedestrian()) {
    clear_has_agent();
      ::carla_server::Pedestrian* temp = agent_.pedestrian_;
    if (GetArenaNoVirtual() != NULL) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    agent_.pedestrian_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::carla_server::Pedestrian& Agent::pedestrian() const {
  // @@protoc_insertion_point(field_get:carla_server.Agent.pedestrian)
  return has_pedestrian()
      ? *agent_.pedestrian_
      : *reinterpret_cast< ::carla_server::Pedestrian*>(&::carla_server::_Pedestrian_default_instance_);
}
inline ::carla_server::Pedestrian* Agent::unsafe_arena_release_pedestrian() {
  // @@protoc_insertion_point(field_unsafe_arena_release:carla_server.Agent.pedestrian)
  if (has_pedestrian()) {
    clear_has_agent();
    ::carla_server::Pedestrian* temp = agent_.pedestrian_;
    agent_.pedestrian_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Agent::unsafe_arena_set_allocated_pedestrian(::carla_server::Pedestrian* pedestrian) {
  clear_agent();
  if (pedestrian) {
    set_has_pedestrian();
    agent_.pedestrian_ = pedestrian;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:carla_server.Agent.pedestrian)
}
inline ::carla_server::Pedestrian* Agent::mutable_pedestrian() {
  if (!has_pedestrian()) {
    clear_agent();
    set_has_pedestrian();
    agent_.pedestrian_ = CreateMaybeMessage< ::carla_server::Pedestrian >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:carla_server.Agent.pedestrian)
  return agent_.pedestrian_;
}

// .carla_server.TrafficLight traffic_light = 4;
inline bool Agent::has_traffic_light() const {
  return agent_case() == kTrafficLight;
}
inline void Agent::set_has_traffic_light() {
  _oneof_case_[0] = kTrafficLight;
}
inline void Agent::clear_traffic_light() {
  if (has_traffic_light()) {
    if (GetArenaNoVirtual() == NULL) {
      delete agent_.traffic_light_;
    }
    clear_has_agent();
  }
}
inline const ::carla_server::TrafficLight& Agent::_internal_traffic_light() const {
  return *agent_.traffic_light_;
}
inline ::carla_server::TrafficLight* Agent::release_traffic_light() {
  // @@protoc_insertion_point(field_release:carla_server.Agent.traffic_light)
  if (has_traffic_light()) {
    clear_has_agent();
      ::carla_server::TrafficLight* temp = agent_.traffic_light_;
    if (GetArenaNoVirtual() != NULL) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    agent_.traffic_light_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::carla_server::TrafficLight& Agent::traffic_light() const {
  // @@protoc_insertion_point(field_get:carla_server.Agent.traffic_light)
  return has_traffic_light()
      ? *agent_.traffic_light_
      : *reinterpret_cast< ::carla_server::TrafficLight*>(&::carla_server::_TrafficLight_default_instance_);
}
inline ::carla_server::TrafficLight* Agent::unsafe_arena_release_traffic_light() {
  // @@protoc_insertion_point(field_unsafe_arena_release:carla_server.Agent.traffic_light)
  if (has_traffic_light()) {
    clear_has_agent();
    ::carla_server::TrafficLight* temp = agent_.traffic_light_;
    agent_.traffic_light_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Agent::unsafe_arena_set_allocated_traffic_light(::carla_server::TrafficLight* traffic_light) {
  clear_agent();
  if (traffic_light) {
    set_has_traffic_light();
    agent_.traffic_light_ = traffic_light;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:carla_server.Agent.traffic_light)
}
inline ::carla_server::TrafficLight* Agent::mutable_traffic_light() {
  if (!has_traffic_light()) {
    clear_agent();
    set_has_traffic_light();
    agent_.traffic_light_ = CreateMaybeMessage< ::carla_server::TrafficLight >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:carla_server.Agent.traffic_light)
  return agent_.traffic_light_;
}

// .carla_server.SpeedLimitSign speed_limit_sign = 5;
inline bool Agent::has_speed_limit_sign() const {
  return agent_case() == kSpeedLimitSign;
}
inline void Agent::set_has_speed_limit_sign() {
  _oneof_case_[0] = kSpeedLimitSign;
}
inline void Agent::clear_speed_limit_sign() {
  if (has_speed_limit_sign()) {
    if (GetArenaNoVirtual() == NULL) {
      delete agent_.speed_limit_sign_;
    }
    clear_has_agent();
  }
}
inline const ::carla_server::SpeedLimitSign& Agent::_internal_speed_limit_sign() const {
  return *agent_.speed_limit_sign_;
}
inline ::carla_server::SpeedLimitSign* Agent::release_speed_limit_sign() {
  // @@protoc_insertion_point(field_release:carla_server.Agent.speed_limit_sign)
  if (has_speed_limit_sign()) {
    clear_has_agent();
      ::carla_server::SpeedLimitSign* temp = agent_.speed_limit_sign_;
    if (GetArenaNoVirtual() != NULL) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    agent_.speed_limit_sign_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::carla_server::SpeedLimitSign& Agent::speed_limit_sign() const {
  // @@protoc_insertion_point(field_get:carla_server.Agent.speed_limit_sign)
  return has_speed_limit_sign()
      ? *agent_.speed_limit_sign_
      : *reinterpret_cast< ::carla_server::SpeedLimitSign*>(&::carla_server::_SpeedLimitSign_default_instance_);
}
inline ::carla_server::SpeedLimitSign* Agent::unsafe_arena_release_speed_limit_sign() {
  // @@protoc_insertion_point(field_unsafe_arena_release:carla_server.Agent.speed_limit_sign)
  if (has_speed_limit_sign()) {
    clear_has_agent();
    ::carla_server::SpeedLimitSign* temp = agent_.speed_limit_sign_;
    agent_.speed_limit_sign_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Agent::unsafe_arena_set_allocated_speed_limit_sign(::carla_server::SpeedLimitSign* speed_limit_sign) {
  clear_agent();
  if (speed_limit_sign) {
    set_has_speed_limit_sign();
    agent_.speed_limit_sign_ = speed_limit_sign;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:carla_server.Agent.speed_limit_sign)
}
inline ::carla_server::SpeedLimitSign* Agent::mutable_speed_limit_sign() {
  if (!has_speed_limit_sign()) {
    clear_agent();
    set_has_speed_limit_sign();
    agent_.speed_limit_sign_ = CreateMaybeMessage< ::carla_server::SpeedLimitSign >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:carla_server.Agent.speed_limit_sign)
  return agent_.speed_limit_sign_;
}

inline bool Agent::has_agent() const {
  return agent_case() != AGENT_NOT_SET;
}
inline void Agent::clear_has_agent() {
  _oneof_case_[0] = AGENT_NOT_SET;
}
inline Agent::AgentCase Agent::agent_case() const {
  return Agent::AgentCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// RequestNewEpisode

// string ini_file = 1;
inline void RequestNewEpisode::clear_ini_file() {
  ini_file_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline const ::std::string& RequestNewEpisode::ini_file() const {
  // @@protoc_insertion_point(field_get:carla_server.RequestNewEpisode.ini_file)
  return ini_file_.Get();
}
inline void RequestNewEpisode::set_ini_file(const ::std::string& value) {
  
  ini_file_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:carla_server.RequestNewEpisode.ini_file)
}
#if LANG_CXX11
inline void RequestNewEpisode::set_ini_file(::std::string&& value) {
  
  ini_file_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:carla_server.RequestNewEpisode.ini_file)
}
#endif
inline void RequestNewEpisode::set_ini_file(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  ini_file_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:carla_server.RequestNewEpisode.ini_file)
}
inline void RequestNewEpisode::set_ini_file(const char* value,
    size_t size) {
  
  ini_file_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:carla_server.RequestNewEpisode.ini_file)
}
inline ::std::string* RequestNewEpisode::mutable_ini_file() {
  
  // @@protoc_insertion_point(field_mutable:carla_server.RequestNewEpisode.ini_file)
  return ini_file_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* RequestNewEpisode::release_ini_file() {
  // @@protoc_insertion_point(field_release:carla_server.RequestNewEpisode.ini_file)
  
  return ini_file_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void RequestNewEpisode::set_allocated_ini_file(::std::string* ini_file) {
  if (ini_file != NULL) {
    
  } else {
    
  }
  ini_file_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ini_file,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:carla_server.RequestNewEpisode.ini_file)
}
inline ::std::string* RequestNewEpisode::unsafe_arena_release_ini_file() {
  // @@protoc_insertion_point(field_unsafe_arena_release:carla_server.RequestNewEpisode.ini_file)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  
  return ini_file_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void RequestNewEpisode::unsafe_arena_set_allocated_ini_file(
    ::std::string* ini_file) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (ini_file != NULL) {
    
  } else {
    
  }
  ini_file_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ini_file, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:carla_server.RequestNewEpisode.ini_file)
}

// -------------------------------------------------------------------

// SceneDescription

// string map_name = 3;
inline void SceneDescription::clear_map_name() {
  map_name_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline const ::std::string& SceneDescription::map_name() const {
  // @@protoc_insertion_point(field_get:carla_server.SceneDescription.map_name)
  return map_name_.Get();
}
inline void SceneDescription::set_map_name(const ::std::string& value) {
  
  map_name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:carla_server.SceneDescription.map_name)
}
#if LANG_CXX11
inline void SceneDescription::set_map_name(::std::string&& value) {
  
  map_name_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:carla_server.SceneDescription.map_name)
}
#endif
inline void SceneDescription::set_map_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  map_name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:carla_server.SceneDescription.map_name)
}
inline void SceneDescription::set_map_name(const char* value,
    size_t size) {
  
  map_name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:carla_server.SceneDescription.map_name)
}
inline ::std::string* SceneDescription::mutable_map_name() {
  
  // @@protoc_insertion_point(field_mutable:carla_server.SceneDescription.map_name)
  return map_name_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* SceneDescription::release_map_name() {
  // @@protoc_insertion_point(field_release:carla_server.SceneDescription.map_name)
  
  return map_name_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void SceneDescription::set_allocated_map_name(::std::string* map_name) {
  if (map_name != NULL) {
    
  } else {
    
  }
  map_name_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), map_name,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:carla_server.SceneDescription.map_name)
}
inline ::std::string* SceneDescription::unsafe_arena_release_map_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:carla_server.SceneDescription.map_name)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  
  return map_name_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void SceneDescription::unsafe_arena_set_allocated_map_name(
    ::std::string* map_name) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (map_name != NULL) {
    
  } else {
    
  }
  map_name_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      map_name, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:carla_server.SceneDescription.map_name)
}

// repeated .carla_server.Transform player_start_spots = 1;
inline int SceneDescription::player_start_spots_size() const {
  return player_start_spots_.size();
}
inline void SceneDescription::clear_player_start_spots() {
  player_start_spots_.Clear();
}
inline ::carla_server::Transform* SceneDescription::mutable_player_start_spots(int index) {
  // @@protoc_insertion_point(field_mutable:carla_server.SceneDescription.player_start_spots)
  return player_start_spots_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::carla_server::Transform >*
SceneDescription::mutable_player_start_spots() {
  // @@protoc_insertion_point(field_mutable_list:carla_server.SceneDescription.player_start_spots)
  return &player_start_spots_;
}
inline const ::carla_server::Transform& SceneDescription::player_start_spots(int index) const {
  // @@protoc_insertion_point(field_get:carla_server.SceneDescription.player_start_spots)
  return player_start_spots_.Get(index);
}
inline ::carla_server::Transform* SceneDescription::add_player_start_spots() {
  // @@protoc_insertion_point(field_add:carla_server.SceneDescription.player_start_spots)
  return player_start_spots_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::carla_server::Transform >&
SceneDescription::player_start_spots() const {
  // @@protoc_insertion_point(field_list:carla_server.SceneDescription.player_start_spots)
  return player_start_spots_;
}

// repeated .carla_server.Sensor sensors = 2;
inline int SceneDescription::sensors_size() const {
  return sensors_.size();
}
inline void SceneDescription::clear_sensors() {
  sensors_.Clear();
}
inline ::carla_server::Sensor* SceneDescription::mutable_sensors(int index) {
  // @@protoc_insertion_point(field_mutable:carla_server.SceneDescription.sensors)
  return sensors_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::carla_server::Sensor >*
SceneDescription::mutable_sensors() {
  // @@protoc_insertion_point(field_mutable_list:carla_server.SceneDescription.sensors)
  return &sensors_;
}
inline const ::carla_server::Sensor& SceneDescription::sensors(int index) const {
  // @@protoc_insertion_point(field_get:carla_server.SceneDescription.sensors)
  return sensors_.Get(index);
}
inline ::carla_server::Sensor* SceneDescription::add_sensors() {
  // @@protoc_insertion_point(field_add:carla_server.SceneDescription.sensors)
  return sensors_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::carla_server::Sensor >&
SceneDescription::sensors() const {
  // @@protoc_insertion_point(field_list:carla_server.SceneDescription.sensors)
  return sensors_;
}

// -------------------------------------------------------------------

// EpisodeStart

// uint32 player_start_spot_index = 1;
inline void EpisodeStart::clear_player_start_spot_index() {
  player_start_spot_index_ = 0u;
}
inline ::google::protobuf::uint32 EpisodeStart::player_start_spot_index() const {
  // @@protoc_insertion_point(field_get:carla_server.EpisodeStart.player_start_spot_index)
  return player_start_spot_index_;
}
inline void EpisodeStart::set_player_start_spot_index(::google::protobuf::uint32 value) {
  
  player_start_spot_index_ = value;
  // @@protoc_insertion_point(field_set:carla_server.EpisodeStart.player_start_spot_index)
}

// -------------------------------------------------------------------

// EpisodeReady

// bool ready = 1;
inline void EpisodeReady::clear_ready() {
  ready_ = false;
}
inline bool EpisodeReady::ready() const {
  // @@protoc_insertion_point(field_get:carla_server.EpisodeReady.ready)
  return ready_;
}
inline void EpisodeReady::set_ready(bool value) {
  
  ready_ = value;
  // @@protoc_insertion_point(field_set:carla_server.EpisodeReady.ready)
}

// -------------------------------------------------------------------

// Control

// float steer = 1;
inline void Control::clear_steer() {
  steer_ = 0;
}
inline float Control::steer() const {
  // @@protoc_insertion_point(field_get:carla_server.Control.steer)
  return steer_;
}
inline void Control::set_steer(float value) {
  
  steer_ = value;
  // @@protoc_insertion_point(field_set:carla_server.Control.steer)
}

// float throttle = 2;
inline void Control::clear_throttle() {
  throttle_ = 0;
}
inline float Control::throttle() const {
  // @@protoc_insertion_point(field_get:carla_server.Control.throttle)
  return throttle_;
}
inline void Control::set_throttle(float value) {
  
  throttle_ = value;
  // @@protoc_insertion_point(field_set:carla_server.Control.throttle)
}

// float brake = 3;
inline void Control::clear_brake() {
  brake_ = 0;
}
inline float Control::brake() const {
  // @@protoc_insertion_point(field_get:carla_server.Control.brake)
  return brake_;
}
inline void Control::set_brake(float value) {
  
  brake_ = value;
  // @@protoc_insertion_point(field_set:carla_server.Control.brake)
}

// bool hand_brake = 4;
inline void Control::clear_hand_brake() {
  hand_brake_ = false;
}
inline bool Control::hand_brake() const {
  // @@protoc_insertion_point(field_get:carla_server.Control.hand_brake)
  return hand_brake_;
}
inline void Control::set_hand_brake(bool value) {
  
  hand_brake_ = value;
  // @@protoc_insertion_point(field_set:carla_server.Control.hand_brake)
}

// bool reverse = 5;
inline void Control::clear_reverse() {
  reverse_ = false;
}
inline bool Control::reverse() const {
  // @@protoc_insertion_point(field_get:carla_server.Control.reverse)
  return reverse_;
}
inline void Control::set_reverse(bool value) {
  
  reverse_ = value;
  // @@protoc_insertion_point(field_set:carla_server.Control.reverse)
}

// -------------------------------------------------------------------

// Measurements_PlayerMeasurements

// .carla_server.Transform transform = 1;
inline bool Measurements_PlayerMeasurements::has_transform() const {
  return this != internal_default_instance() && transform_ != NULL;
}
inline void Measurements_PlayerMeasurements::clear_transform() {
  if (GetArenaNoVirtual() == NULL && transform_ != NULL) {
    delete transform_;
  }
  transform_ = NULL;
}
inline const ::carla_server::Transform& Measurements_PlayerMeasurements::_internal_transform() const {
  return *transform_;
}
inline const ::carla_server::Transform& Measurements_PlayerMeasurements::transform() const {
  const ::carla_server::Transform* p = transform_;
  // @@protoc_insertion_point(field_get:carla_server.Measurements.PlayerMeasurements.transform)
  return p != NULL ? *p : *reinterpret_cast<const ::carla_server::Transform*>(
      &::carla_server::_Transform_default_instance_);
}
inline ::carla_server::Transform* Measurements_PlayerMeasurements::release_transform() {
  // @@protoc_insertion_point(field_release:carla_server.Measurements.PlayerMeasurements.transform)
  
  ::carla_server::Transform* temp = transform_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  transform_ = NULL;
  return temp;
}
inline ::carla_server::Transform* Measurements_PlayerMeasurements::unsafe_arena_release_transform() {
  // @@protoc_insertion_point(field_unsafe_arena_release:carla_server.Measurements.PlayerMeasurements.transform)
  
  ::carla_server::Transform* temp = transform_;
  transform_ = NULL;
  return temp;
}
inline ::carla_server::Transform* Measurements_PlayerMeasurements::mutable_transform() {
  
  if (transform_ == NULL) {
    auto* p = CreateMaybeMessage<::carla_server::Transform>(GetArenaNoVirtual());
    transform_ = p;
  }
  // @@protoc_insertion_point(field_mutable:carla_server.Measurements.PlayerMeasurements.transform)
  return transform_;
}
inline void Measurements_PlayerMeasurements::set_allocated_transform(::carla_server::Transform* transform) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete transform_;
  }
  if (transform) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(transform);
    if (message_arena != submessage_arena) {
      transform = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, transform, submessage_arena);
    }
    
  } else {
    
  }
  transform_ = transform;
  // @@protoc_insertion_point(field_set_allocated:carla_server.Measurements.PlayerMeasurements.transform)
}

// .carla_server.BoundingBox bounding_box = 12;
inline bool Measurements_PlayerMeasurements::has_bounding_box() const {
  return this != internal_default_instance() && bounding_box_ != NULL;
}
inline void Measurements_PlayerMeasurements::clear_bounding_box() {
  if (GetArenaNoVirtual() == NULL && bounding_box_ != NULL) {
    delete bounding_box_;
  }
  bounding_box_ = NULL;
}
inline const ::carla_server::BoundingBox& Measurements_PlayerMeasurements::_internal_bounding_box() const {
  return *bounding_box_;
}
inline const ::carla_server::BoundingBox& Measurements_PlayerMeasurements::bounding_box() const {
  const ::carla_server::BoundingBox* p = bounding_box_;
  // @@protoc_insertion_point(field_get:carla_server.Measurements.PlayerMeasurements.bounding_box)
  return p != NULL ? *p : *reinterpret_cast<const ::carla_server::BoundingBox*>(
      &::carla_server::_BoundingBox_default_instance_);
}
inline ::carla_server::BoundingBox* Measurements_PlayerMeasurements::release_bounding_box() {
  // @@protoc_insertion_point(field_release:carla_server.Measurements.PlayerMeasurements.bounding_box)
  
  ::carla_server::BoundingBox* temp = bounding_box_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  bounding_box_ = NULL;
  return temp;
}
inline ::carla_server::BoundingBox* Measurements_PlayerMeasurements::unsafe_arena_release_bounding_box() {
  // @@protoc_insertion_point(field_unsafe_arena_release:carla_server.Measurements.PlayerMeasurements.bounding_box)
  
  ::carla_server::BoundingBox* temp = bounding_box_;
  bounding_box_ = NULL;
  return temp;
}
inline ::carla_server::BoundingBox* Measurements_PlayerMeasurements::mutable_bounding_box() {
  
  if (bounding_box_ == NULL) {
    auto* p = CreateMaybeMessage<::carla_server::BoundingBox>(GetArenaNoVirtual());
    bounding_box_ = p;
  }
  // @@protoc_insertion_point(field_mutable:carla_server.Measurements.PlayerMeasurements.bounding_box)
  return bounding_box_;
}
inline void Measurements_PlayerMeasurements::set_allocated_bounding_box(::carla_server::BoundingBox* bounding_box) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete bounding_box_;
  }
  if (bounding_box) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(bounding_box);
    if (message_arena != submessage_arena) {
      bounding_box = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, bounding_box, submessage_arena);
    }
    
  } else {
    
  }
  bounding_box_ = bounding_box;
  // @@protoc_insertion_point(field_set_allocated:carla_server.Measurements.PlayerMeasurements.bounding_box)
}

// .carla_server.Vector3D acceleration = 3;
inline bool Measurements_PlayerMeasurements::has_acceleration() const {
  return this != internal_default_instance() && acceleration_ != NULL;
}
inline void Measurements_PlayerMeasurements::clear_acceleration() {
  if (GetArenaNoVirtual() == NULL && acceleration_ != NULL) {
    delete acceleration_;
  }
  acceleration_ = NULL;
}
inline const ::carla_server::Vector3D& Measurements_PlayerMeasurements::_internal_acceleration() const {
  return *acceleration_;
}
inline const ::carla_server::Vector3D& Measurements_PlayerMeasurements::acceleration() const {
  const ::carla_server::Vector3D* p = acceleration_;
  // @@protoc_insertion_point(field_get:carla_server.Measurements.PlayerMeasurements.acceleration)
  return p != NULL ? *p : *reinterpret_cast<const ::carla_server::Vector3D*>(
      &::carla_server::_Vector3D_default_instance_);
}
inline ::carla_server::Vector3D* Measurements_PlayerMeasurements::release_acceleration() {
  // @@protoc_insertion_point(field_release:carla_server.Measurements.PlayerMeasurements.acceleration)
  
  ::carla_server::Vector3D* temp = acceleration_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  acceleration_ = NULL;
  return temp;
}
inline ::carla_server::Vector3D* Measurements_PlayerMeasurements::unsafe_arena_release_acceleration() {
  // @@protoc_insertion_point(field_unsafe_arena_release:carla_server.Measurements.PlayerMeasurements.acceleration)
  
  ::carla_server::Vector3D* temp = acceleration_;
  acceleration_ = NULL;
  return temp;
}
inline ::carla_server::Vector3D* Measurements_PlayerMeasurements::mutable_acceleration() {
  
  if (acceleration_ == NULL) {
    auto* p = CreateMaybeMessage<::carla_server::Vector3D>(GetArenaNoVirtual());
    acceleration_ = p;
  }
  // @@protoc_insertion_point(field_mutable:carla_server.Measurements.PlayerMeasurements.acceleration)
  return acceleration_;
}
inline void Measurements_PlayerMeasurements::set_allocated_acceleration(::carla_server::Vector3D* acceleration) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete acceleration_;
  }
  if (acceleration) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(acceleration);
    if (message_arena != submessage_arena) {
      acceleration = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, acceleration, submessage_arena);
    }
    
  } else {
    
  }
  acceleration_ = acceleration;
  // @@protoc_insertion_point(field_set_allocated:carla_server.Measurements.PlayerMeasurements.acceleration)
}

// float forward_speed = 4;
inline void Measurements_PlayerMeasurements::clear_forward_speed() {
  forward_speed_ = 0;
}
inline float Measurements_PlayerMeasurements::forward_speed() const {
  // @@protoc_insertion_point(field_get:carla_server.Measurements.PlayerMeasurements.forward_speed)
  return forward_speed_;
}
inline void Measurements_PlayerMeasurements::set_forward_speed(float value) {
  
  forward_speed_ = value;
  // @@protoc_insertion_point(field_set:carla_server.Measurements.PlayerMeasurements.forward_speed)
}

// float collision_vehicles = 5;
inline void Measurements_PlayerMeasurements::clear_collision_vehicles() {
  collision_vehicles_ = 0;
}
inline float Measurements_PlayerMeasurements::collision_vehicles() const {
  // @@protoc_insertion_point(field_get:carla_server.Measurements.PlayerMeasurements.collision_vehicles)
  return collision_vehicles_;
}
inline void Measurements_PlayerMeasurements::set_collision_vehicles(float value) {
  
  collision_vehicles_ = value;
  // @@protoc_insertion_point(field_set:carla_server.Measurements.PlayerMeasurements.collision_vehicles)
}

// float collision_pedestrians = 6;
inline void Measurements_PlayerMeasurements::clear_collision_pedestrians() {
  collision_pedestrians_ = 0;
}
inline float Measurements_PlayerMeasurements::collision_pedestrians() const {
  // @@protoc_insertion_point(field_get:carla_server.Measurements.PlayerMeasurements.collision_pedestrians)
  return collision_pedestrians_;
}
inline void Measurements_PlayerMeasurements::set_collision_pedestrians(float value) {
  
  collision_pedestrians_ = value;
  // @@protoc_insertion_point(field_set:carla_server.Measurements.PlayerMeasurements.collision_pedestrians)
}

// float collision_other = 7;
inline void Measurements_PlayerMeasurements::clear_collision_other() {
  collision_other_ = 0;
}
inline float Measurements_PlayerMeasurements::collision_other() const {
  // @@protoc_insertion_point(field_get:carla_server.Measurements.PlayerMeasurements.collision_other)
  return collision_other_;
}
inline void Measurements_PlayerMeasurements::set_collision_other(float value) {
  
  collision_other_ = value;
  // @@protoc_insertion_point(field_set:carla_server.Measurements.PlayerMeasurements.collision_other)
}

// float intersection_otherlane = 8;
inline void Measurements_PlayerMeasurements::clear_intersection_otherlane() {
  intersection_otherlane_ = 0;
}
inline float Measurements_PlayerMeasurements::intersection_otherlane() const {
  // @@protoc_insertion_point(field_get:carla_server.Measurements.PlayerMeasurements.intersection_otherlane)
  return intersection_otherlane_;
}
inline void Measurements_PlayerMeasurements::set_intersection_otherlane(float value) {
  
  intersection_otherlane_ = value;
  // @@protoc_insertion_point(field_set:carla_server.Measurements.PlayerMeasurements.intersection_otherlane)
}

// float intersection_offroad = 9;
inline void Measurements_PlayerMeasurements::clear_intersection_offroad() {
  intersection_offroad_ = 0;
}
inline float Measurements_PlayerMeasurements::intersection_offroad() const {
  // @@protoc_insertion_point(field_get:carla_server.Measurements.PlayerMeasurements.intersection_offroad)
  return intersection_offroad_;
}
inline void Measurements_PlayerMeasurements::set_intersection_offroad(float value) {
  
  intersection_offroad_ = value;
  // @@protoc_insertion_point(field_set:carla_server.Measurements.PlayerMeasurements.intersection_offroad)
}

// .carla_server.Control autopilot_control = 10;
inline bool Measurements_PlayerMeasurements::has_autopilot_control() const {
  return this != internal_default_instance() && autopilot_control_ != NULL;
}
inline void Measurements_PlayerMeasurements::clear_autopilot_control() {
  if (GetArenaNoVirtual() == NULL && autopilot_control_ != NULL) {
    delete autopilot_control_;
  }
  autopilot_control_ = NULL;
}
inline const ::carla_server::Control& Measurements_PlayerMeasurements::_internal_autopilot_control() const {
  return *autopilot_control_;
}
inline const ::carla_server::Control& Measurements_PlayerMeasurements::autopilot_control() const {
  const ::carla_server::Control* p = autopilot_control_;
  // @@protoc_insertion_point(field_get:carla_server.Measurements.PlayerMeasurements.autopilot_control)
  return p != NULL ? *p : *reinterpret_cast<const ::carla_server::Control*>(
      &::carla_server::_Control_default_instance_);
}
inline ::carla_server::Control* Measurements_PlayerMeasurements::release_autopilot_control() {
  // @@protoc_insertion_point(field_release:carla_server.Measurements.PlayerMeasurements.autopilot_control)
  
  ::carla_server::Control* temp = autopilot_control_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  autopilot_control_ = NULL;
  return temp;
}
inline ::carla_server::Control* Measurements_PlayerMeasurements::unsafe_arena_release_autopilot_control() {
  // @@protoc_insertion_point(field_unsafe_arena_release:carla_server.Measurements.PlayerMeasurements.autopilot_control)
  
  ::carla_server::Control* temp = autopilot_control_;
  autopilot_control_ = NULL;
  return temp;
}
inline ::carla_server::Control* Measurements_PlayerMeasurements::mutable_autopilot_control() {
  
  if (autopilot_control_ == NULL) {
    auto* p = CreateMaybeMessage<::carla_server::Control>(GetArenaNoVirtual());
    autopilot_control_ = p;
  }
  // @@protoc_insertion_point(field_mutable:carla_server.Measurements.PlayerMeasurements.autopilot_control)
  return autopilot_control_;
}
inline void Measurements_PlayerMeasurements::set_allocated_autopilot_control(::carla_server::Control* autopilot_control) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete autopilot_control_;
  }
  if (autopilot_control) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(autopilot_control);
    if (message_arena != submessage_arena) {
      autopilot_control = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, autopilot_control, submessage_arena);
    }
    
  } else {
    
  }
  autopilot_control_ = autopilot_control;
  // @@protoc_insertion_point(field_set_allocated:carla_server.Measurements.PlayerMeasurements.autopilot_control)
}

// -------------------------------------------------------------------

// Measurements

// uint64 frame_number = 5;
inline void Measurements::clear_frame_number() {
  frame_number_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Measurements::frame_number() const {
  // @@protoc_insertion_point(field_get:carla_server.Measurements.frame_number)
  return frame_number_;
}
inline void Measurements::set_frame_number(::google::protobuf::uint64 value) {
  
  frame_number_ = value;
  // @@protoc_insertion_point(field_set:carla_server.Measurements.frame_number)
}

// uint32 platform_timestamp = 1;
inline void Measurements::clear_platform_timestamp() {
  platform_timestamp_ = 0u;
}
inline ::google::protobuf::uint32 Measurements::platform_timestamp() const {
  // @@protoc_insertion_point(field_get:carla_server.Measurements.platform_timestamp)
  return platform_timestamp_;
}
inline void Measurements::set_platform_timestamp(::google::protobuf::uint32 value) {
  
  platform_timestamp_ = value;
  // @@protoc_insertion_point(field_set:carla_server.Measurements.platform_timestamp)
}

// uint32 game_timestamp = 2;
inline void Measurements::clear_game_timestamp() {
  game_timestamp_ = 0u;
}
inline ::google::protobuf::uint32 Measurements::game_timestamp() const {
  // @@protoc_insertion_point(field_get:carla_server.Measurements.game_timestamp)
  return game_timestamp_;
}
inline void Measurements::set_game_timestamp(::google::protobuf::uint32 value) {
  
  game_timestamp_ = value;
  // @@protoc_insertion_point(field_set:carla_server.Measurements.game_timestamp)
}

// .carla_server.Measurements.PlayerMeasurements player_measurements = 3;
inline bool Measurements::has_player_measurements() const {
  return this != internal_default_instance() && player_measurements_ != NULL;
}
inline void Measurements::clear_player_measurements() {
  if (GetArenaNoVirtual() == NULL && player_measurements_ != NULL) {
    delete player_measurements_;
  }
  player_measurements_ = NULL;
}
inline const ::carla_server::Measurements_PlayerMeasurements& Measurements::_internal_player_measurements() const {
  return *player_measurements_;
}
inline const ::carla_server::Measurements_PlayerMeasurements& Measurements::player_measurements() const {
  const ::carla_server::Measurements_PlayerMeasurements* p = player_measurements_;
  // @@protoc_insertion_point(field_get:carla_server.Measurements.player_measurements)
  return p != NULL ? *p : *reinterpret_cast<const ::carla_server::Measurements_PlayerMeasurements*>(
      &::carla_server::_Measurements_PlayerMeasurements_default_instance_);
}
inline ::carla_server::Measurements_PlayerMeasurements* Measurements::release_player_measurements() {
  // @@protoc_insertion_point(field_release:carla_server.Measurements.player_measurements)
  
  ::carla_server::Measurements_PlayerMeasurements* temp = player_measurements_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  player_measurements_ = NULL;
  return temp;
}
inline ::carla_server::Measurements_PlayerMeasurements* Measurements::unsafe_arena_release_player_measurements() {
  // @@protoc_insertion_point(field_unsafe_arena_release:carla_server.Measurements.player_measurements)
  
  ::carla_server::Measurements_PlayerMeasurements* temp = player_measurements_;
  player_measurements_ = NULL;
  return temp;
}
inline ::carla_server::Measurements_PlayerMeasurements* Measurements::mutable_player_measurements() {
  
  if (player_measurements_ == NULL) {
    auto* p = CreateMaybeMessage<::carla_server::Measurements_PlayerMeasurements>(GetArenaNoVirtual());
    player_measurements_ = p;
  }
  // @@protoc_insertion_point(field_mutable:carla_server.Measurements.player_measurements)
  return player_measurements_;
}
inline void Measurements::set_allocated_player_measurements(::carla_server::Measurements_PlayerMeasurements* player_measurements) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete player_measurements_;
  }
  if (player_measurements) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(player_measurements);
    if (message_arena != submessage_arena) {
      player_measurements = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, player_measurements, submessage_arena);
    }
    
  } else {
    
  }
  player_measurements_ = player_measurements;
  // @@protoc_insertion_point(field_set_allocated:carla_server.Measurements.player_measurements)
}

// repeated .carla_server.Agent non_player_agents = 4;
inline int Measurements::non_player_agents_size() const {
  return non_player_agents_.size();
}
inline void Measurements::clear_non_player_agents() {
  non_player_agents_.Clear();
}
inline ::carla_server::Agent* Measurements::mutable_non_player_agents(int index) {
  // @@protoc_insertion_point(field_mutable:carla_server.Measurements.non_player_agents)
  return non_player_agents_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::carla_server::Agent >*
Measurements::mutable_non_player_agents() {
  // @@protoc_insertion_point(field_mutable_list:carla_server.Measurements.non_player_agents)
  return &non_player_agents_;
}
inline const ::carla_server::Agent& Measurements::non_player_agents(int index) const {
  // @@protoc_insertion_point(field_get:carla_server.Measurements.non_player_agents)
  return non_player_agents_.Get(index);
}
inline ::carla_server::Agent* Measurements::add_non_player_agents() {
  // @@protoc_insertion_point(field_add:carla_server.Measurements.non_player_agents)
  return non_player_agents_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::carla_server::Agent >&
Measurements::non_player_agents() const {
  // @@protoc_insertion_point(field_list:carla_server.Measurements.non_player_agents)
  return non_player_agents_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace carla_server

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::carla_server::Sensor_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::carla_server::Sensor_Type>() {
  return ::carla_server::Sensor_Type_descriptor();
}
template <> struct is_proto_enum< ::carla_server::TrafficLight_State> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::carla_server::TrafficLight_State>() {
  return ::carla_server::TrafficLight_State_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_carla_5fserver_2eproto
